<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Crypto++ Library: C:/Users/Admin/Downloads/NT219/cryptopp/misc.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Crypto++ Library
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('misc_8h.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">misc.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Utility functions for the Crypto++ library.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="config_8h_source.html">config.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="cryptlib_8h_source.html">cryptlib.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="secblockfwd_8h_source.html">secblockfwd.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="smartptr_8h_source.html">smartptr.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="stdcpp_8h_source.html">stdcpp.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="trap_8h_source.html">trap.h</a>&quot;</code><br />
</div>
<p><a href="misc_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_compile_assert.html">CompileAssert&lt; b &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_empty.html">Empty</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="class_empty.html" title="An Empty class.">Empty</a> class.  <a href="class_empty.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_two_bases.html">TwoBases&lt; BASE1, BASE2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_three_bases.html">ThreeBases&lt; BASE1, BASE2, BASE3 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_holder.html">ObjectHolder&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses encapsulation to hide an object in derived classes.  <a href="class_object_holder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_not_copyable.html">NotCopyable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures an object is not copyable.  <a href="class_not_copyable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_new_object.html">NewObject&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object factory function.  <a href="struct_new_object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_singleton.html">Singleton&lt; T, F, instance &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restricts the instantiation of a class to one static object without locks.  <a href="class_singleton.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_get_block.html">GetBlock&lt; T, B, A &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access a block of memory.  <a href="class_get_block.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_put_block.html">PutBlock&lt; T, B, A &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access a block of memory.  <a href="class_put_block.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_block_get_and_put.html">BlockGetAndPut&lt; T, B, GA, PA &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access a block of memory.  <a href="struct_block_get_and_put.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_safe_shifter_3_01true_01_4.html">SafeShifter&lt; true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts a value in the presence of overflow.  <a href="struct_safe_shifter_3_01true_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_safe_shifter_3_01false_01_4.html">SafeShifter&lt; false &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts a value in the absence of overflow.  <a href="struct_safe_shifter_3_01false_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a9c7136e2091dd0e0fb5d4e97010b8430" id="r_a9c7136e2091dd0e0fb5d4e97010b8430"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c7136e2091dd0e0fb5d4e97010b8430">CRYPTOPP_FAST_ROTATE</a>(x)</td></tr>
<tr class="separator:a9c7136e2091dd0e0fb5d4e97010b8430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c75bb398badb69c7577b21486f9963f" id="r_a3c75bb398badb69c7577b21486f9963f"><td class="memItemLeft" align="right" valign="top"><a id="a3c75bb398badb69c7577b21486f9963f" name="a3c75bb398badb69c7577b21486f9963f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SIZE_MAX</b>&#160;&#160;&#160;((std::numeric_limits&lt;size_t&gt;::max)())</td></tr>
<tr class="separator:a3c75bb398badb69c7577b21486f9963f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07644575199e2dc5fa4eac13c3dea2e" id="r_ab07644575199e2dc5fa4eac13c3dea2e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab07644575199e2dc5fa4eac13c3dea2e">CRYPTOPP_COMPILE_ASSERT</a>(assertion)</td></tr>
<tr class="separator:ab07644575199e2dc5fa4eac13c3dea2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a687aa2e764e0e2f1f4649e68d9869a3b" id="r_a687aa2e764e0e2f1f4649e68d9869a3b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a687aa2e764e0e2f1f4649e68d9869a3b">CRYPTOPP_ASSERT_JOIN</a>(X,  Y)</td></tr>
<tr class="separator:a687aa2e764e0e2f1f4649e68d9869a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed3676a29b97ad67ab9efc2682ef78d4" id="r_aed3676a29b97ad67ab9efc2682ef78d4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed3676a29b97ad67ab9efc2682ef78d4">CRYPTOPP_DO_ASSERT_JOIN</a>(X,  Y)</td></tr>
<tr class="separator:aed3676a29b97ad67ab9efc2682ef78d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4002b9b8cfe3baff72fc606a0525c2fe" id="r_a4002b9b8cfe3baff72fc606a0525c2fe"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4002b9b8cfe3baff72fc606a0525c2fe">CRYPTOPP_COMPILE_ASSERT_INSTANCE</a>(assertion,  instance)</td></tr>
<tr class="separator:a4002b9b8cfe3baff72fc606a0525c2fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc2b6e8b1b96a4ed267a8cec32a92425" id="r_acc2b6e8b1b96a4ed267a8cec32a92425"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc2b6e8b1b96a4ed267a8cec32a92425">COUNTOF</a>(x)</td></tr>
<tr class="separator:acc2b6e8b1b96a4ed267a8cec32a92425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56d4cbe1e093c683432a147eb1ccb293" id="r_a56d4cbe1e093c683432a147eb1ccb293"><td class="memItemLeft" align="right" valign="top"><a id="a56d4cbe1e093c683432a147eb1ccb293" name="a56d4cbe1e093c683432a147eb1ccb293"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MEMORY_BARRIER</b>()</td></tr>
<tr class="separator:a56d4cbe1e093c683432a147eb1ccb293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1938a2627b812913ac3d50c93fd5f11" id="r_ad1938a2627b812913ac3d50c93fd5f11"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1938a2627b812913ac3d50c93fd5f11">EnumToInt</a>(v)</td></tr>
<tr class="memdesc:ad1938a2627b812913ac3d50c93fd5f11"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_integer.html" title="Multiple precision integer with arithmetic operations.">Integer</a> value.  <br /></td></tr>
<tr class="separator:ad1938a2627b812913ac3d50c93fd5f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff336cfe214604ffdd1075d94a11f8c5" id="r_aff336cfe214604ffdd1075d94a11f8c5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff336cfe214604ffdd1075d94a11f8c5">RETURN_IF_NONZERO</a>(x)</td></tr>
<tr class="separator:aff336cfe214604ffdd1075d94a11f8c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5d495902796a542084124233281265" id="r_afb5d495902796a542084124233281265"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb5d495902796a542084124233281265">GETBYTE</a>(x,  y)</td></tr>
<tr class="separator:afb5d495902796a542084124233281265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb110e20bd83872104cf1b5a0d19ff1e" id="r_afb110e20bd83872104cf1b5a0d19ff1e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb110e20bd83872104cf1b5a0d19ff1e">CRYPTOPP_GET_BYTE_AS_BYTE</a>(x,  y)</td></tr>
<tr class="separator:afb110e20bd83872104cf1b5a0d19ff1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab44245f76e0fc08ab8ba76771ef3d9f5" id="r_ab44245f76e0fc08ab8ba76771ef3d9f5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab44245f76e0fc08ab8ba76771ef3d9f5">CRYPTOPP_BLOCK_1</a>(n,  t,  s)</td></tr>
<tr class="separator:ab44245f76e0fc08ab8ba76771ef3d9f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca956e0abd7368e25cebeb9513616eca" id="r_aca956e0abd7368e25cebeb9513616eca"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca956e0abd7368e25cebeb9513616eca">CRYPTOPP_BLOCK_2</a>(n,  t,  s)</td></tr>
<tr class="separator:aca956e0abd7368e25cebeb9513616eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a4e24d34c37d65a379bd06a4bf12d2" id="r_a48a4e24d34c37d65a379bd06a4bf12d2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48a4e24d34c37d65a379bd06a4bf12d2">CRYPTOPP_BLOCK_3</a>(n,  t,  s)</td></tr>
<tr class="separator:a48a4e24d34c37d65a379bd06a4bf12d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e8366a854dd78fbaba4da6ace69b3b4" id="r_a5e8366a854dd78fbaba4da6ace69b3b4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e8366a854dd78fbaba4da6ace69b3b4">CRYPTOPP_BLOCK_4</a>(n,  t,  s)</td></tr>
<tr class="separator:a5e8366a854dd78fbaba4da6ace69b3b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d00455e80e440dde3572996227bf0f0" id="r_a3d00455e80e440dde3572996227bf0f0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d00455e80e440dde3572996227bf0f0">CRYPTOPP_BLOCK_5</a>(n,  t,  s)</td></tr>
<tr class="separator:a3d00455e80e440dde3572996227bf0f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11940604e7e44c16170ab0bc89e4e8f6" id="r_a11940604e7e44c16170ab0bc89e4e8f6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11940604e7e44c16170ab0bc89e4e8f6">CRYPTOPP_BLOCK_6</a>(n,  t,  s)</td></tr>
<tr class="separator:a11940604e7e44c16170ab0bc89e4e8f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fee2fd43faebed6eac61f1f3d8bc423" id="r_a4fee2fd43faebed6eac61f1f3d8bc423"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4fee2fd43faebed6eac61f1f3d8bc423">CRYPTOPP_BLOCK_7</a>(n,  t,  s)</td></tr>
<tr class="separator:a4fee2fd43faebed6eac61f1f3d8bc423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ac56e108366ccfa9c5ecf923b52e936" id="r_a4ac56e108366ccfa9c5ecf923b52e936"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ac56e108366ccfa9c5ecf923b52e936">CRYPTOPP_BLOCK_8</a>(n,  t,  s)</td></tr>
<tr class="separator:a4ac56e108366ccfa9c5ecf923b52e936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade27627ae9dfbc2bee30153a513e229c" id="r_ade27627ae9dfbc2bee30153a513e229c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade27627ae9dfbc2bee30153a513e229c">CRYPTOPP_BLOCKS_END</a>(i)</td></tr>
<tr class="separator:ade27627ae9dfbc2bee30153a513e229c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:abe16d69257b3c86de97e8b0a9e851771" id="r_abe16d69257b3c86de97e8b0a9e851771"><td class="memTemplParams" colspan="2">template&lt;typename PTR, typename OFF&gt; </td></tr>
<tr class="memitem:abe16d69257b3c86de97e8b0a9e851771"><td class="memTemplItemLeft" align="right" valign="top">PTR&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abe16d69257b3c86de97e8b0a9e851771">PtrAdd</a> (PTR pointer, OFF offset)</td></tr>
<tr class="memdesc:abe16d69257b3c86de97e8b0a9e851771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pointer with an offset.  <br /></td></tr>
<tr class="separator:abe16d69257b3c86de97e8b0a9e851771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e456f139d55e27318ba09d6a06d7960" id="r_a5e456f139d55e27318ba09d6a06d7960"><td class="memTemplParams" colspan="2">template&lt;typename PTR, typename OFF&gt; </td></tr>
<tr class="memitem:a5e456f139d55e27318ba09d6a06d7960"><td class="memTemplItemLeft" align="right" valign="top">PTR&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5e456f139d55e27318ba09d6a06d7960">PtrSub</a> (PTR pointer, OFF offset)</td></tr>
<tr class="memdesc:a5e456f139d55e27318ba09d6a06d7960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pointer with an offset.  <br /></td></tr>
<tr class="separator:a5e456f139d55e27318ba09d6a06d7960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0afa8559681afcdbe5cd415cbde63e9" id="r_aa0afa8559681afcdbe5cd415cbde63e9"><td class="memTemplParams" colspan="2">template&lt;typename PTR&gt; </td></tr>
<tr class="memitem:aa0afa8559681afcdbe5cd415cbde63e9"><td class="memTemplItemLeft" align="right" valign="top">ptrdiff_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa0afa8559681afcdbe5cd415cbde63e9">PtrDiff</a> (const PTR pointer1, const PTR pointer2)</td></tr>
<tr class="memdesc:aa0afa8559681afcdbe5cd415cbde63e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine pointer difference.  <br /></td></tr>
<tr class="separator:aa0afa8559681afcdbe5cd415cbde63e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acacdab7254aa8a8bd6b56e2abb7b9083" id="r_acacdab7254aa8a8bd6b56e2abb7b9083"><td class="memTemplParams" colspan="2">template&lt;typename PTR&gt; </td></tr>
<tr class="memitem:acacdab7254aa8a8bd6b56e2abb7b9083"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acacdab7254aa8a8bd6b56e2abb7b9083">PtrByteDiff</a> (const PTR pointer1, const PTR pointer2)</td></tr>
<tr class="memdesc:acacdab7254aa8a8bd6b56e2abb7b9083"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine pointer difference.  <br /></td></tr>
<tr class="separator:acacdab7254aa8a8bd6b56e2abb7b9083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6d8b623aebbbb1c4bfba1b8ba1ce25d" id="r_ad6d8b623aebbbb1c4bfba1b8ba1ce25d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6d8b623aebbbb1c4bfba1b8ba1ce25d">BytePtr</a> (std::string &amp;str)</td></tr>
<tr class="memdesc:ad6d8b623aebbbb1c4bfba1b8ba1ce25d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the first element of a string.  <br /></td></tr>
<tr class="separator:ad6d8b623aebbbb1c4bfba1b8ba1ce25d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2d3a3222f6af55a6644b1f3e982b896" id="r_ae2d3a3222f6af55a6644b1f3e982b896"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2d3a3222f6af55a6644b1f3e982b896">BytePtr</a> (<a class="el" href="class_sec_block.html">SecByteBlock</a> &amp;str)</td></tr>
<tr class="memdesc:ae2d3a3222f6af55a6644b1f3e982b896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the first element of a string.  <br /></td></tr>
<tr class="separator:ae2d3a3222f6af55a6644b1f3e982b896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e44f8326c04036c4fbcde30cb5ab9e2" id="r_a7e44f8326c04036c4fbcde30cb5ab9e2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e44f8326c04036c4fbcde30cb5ab9e2">ConstBytePtr</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:a7e44f8326c04036c4fbcde30cb5ab9e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const pointer to the first element of a string.  <br /></td></tr>
<tr class="separator:a7e44f8326c04036c4fbcde30cb5ab9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05cd70251b65c2de16dfbfc43bf26056" id="r_a05cd70251b65c2de16dfbfc43bf26056"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05cd70251b65c2de16dfbfc43bf26056">ConstBytePtr</a> (const <a class="el" href="class_sec_block.html">SecByteBlock</a> &amp;str)</td></tr>
<tr class="memdesc:a05cd70251b65c2de16dfbfc43bf26056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const pointer to the first element of a string.  <br /></td></tr>
<tr class="separator:a05cd70251b65c2de16dfbfc43bf26056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24eea25739f5000af6c684b8c225c6be" id="r_a24eea25739f5000af6c684b8c225c6be"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24eea25739f5000af6c684b8c225c6be">BytePtrSize</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:a24eea25739f5000af6c684b8c225c6be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of a string.  <br /></td></tr>
<tr class="separator:a24eea25739f5000af6c684b8c225c6be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935acdd6640d177065caca6ddbab2ef2" id="r_a935acdd6640d177065caca6ddbab2ef2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a935acdd6640d177065caca6ddbab2ef2">BytePtrSize</a> (const <a class="el" href="class_sec_block.html">SecByteBlock</a> &amp;str)</td></tr>
<tr class="memdesc:a935acdd6640d177065caca6ddbab2ef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of a string.  <br /></td></tr>
<tr class="separator:a935acdd6640d177065caca6ddbab2ef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f6fcbaaf6f72fe46a6d911b033dfea0" id="r_a5f6fcbaaf6f72fe46a6d911b033dfea0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f6fcbaaf6f72fe46a6d911b033dfea0">memcpy_s</a> (void *dest, size_t sizeInBytes, const void *src, size_t count)</td></tr>
<tr class="memdesc:a5f6fcbaaf6f72fe46a6d911b033dfea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounds checking replacement for memcpy()  <br /></td></tr>
<tr class="separator:a5f6fcbaaf6f72fe46a6d911b033dfea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb296eab4ca31ab5c0cf4a932488a8de" id="r_adb296eab4ca31ab5c0cf4a932488a8de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb296eab4ca31ab5c0cf4a932488a8de">memmove_s</a> (void *dest, size_t sizeInBytes, const void *src, size_t count)</td></tr>
<tr class="memdesc:adb296eab4ca31ab5c0cf4a932488a8de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounds checking replacement for memmove()  <br /></td></tr>
<tr class="separator:adb296eab4ca31ab5c0cf4a932488a8de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a810542d642def73fd278c08092417e11" id="r_a810542d642def73fd278c08092417e11"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:a810542d642def73fd278c08092417e11"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a810542d642def73fd278c08092417e11">vec_swap</a> (T &amp;a, T &amp;b)</td></tr>
<tr class="memdesc:a810542d642def73fd278c08092417e11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps two variables which are arrays.  <br /></td></tr>
<tr class="separator:a810542d642def73fd278c08092417e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a356f99a6c1d7ae03f56a70ee1ecc1a22" id="r_a356f99a6c1d7ae03f56a70ee1ecc1a22"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a356f99a6c1d7ae03f56a70ee1ecc1a22">memset_z</a> (void *ptr, int val, size_t num)</td></tr>
<tr class="memdesc:a356f99a6c1d7ae03f56a70ee1ecc1a22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory block initializer.  <br /></td></tr>
<tr class="separator:a356f99a6c1d7ae03f56a70ee1ecc1a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6870af46b8ad78fd77c724d9ccd48fdc" id="r_a6870af46b8ad78fd77c724d9ccd48fdc"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:a6870af46b8ad78fd77c724d9ccd48fdc"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6870af46b8ad78fd77c724d9ccd48fdc">STDMIN</a> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="memdesc:a6870af46b8ad78fd77c724d9ccd48fdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replacement function for std::min.  <br /></td></tr>
<tr class="separator:a6870af46b8ad78fd77c724d9ccd48fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3666860179c072fc5222f9b6dacefcb5" id="r_a3666860179c072fc5222f9b6dacefcb5"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:a3666860179c072fc5222f9b6dacefcb5"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3666860179c072fc5222f9b6dacefcb5">STDMAX</a> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="memdesc:a3666860179c072fc5222f9b6dacefcb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replacement function for std::max.  <br /></td></tr>
<tr class="separator:a3666860179c072fc5222f9b6dacefcb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8391e7d9d613a6c401787d2cdab1f51" id="r_ac8391e7d9d613a6c401787d2cdab1f51"><td class="memTemplParams" colspan="2">template&lt;class T1, class T2&gt; </td></tr>
<tr class="memitem:ac8391e7d9d613a6c401787d2cdab1f51"><td class="memTemplItemLeft" align="right" valign="top">const T1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac8391e7d9d613a6c401787d2cdab1f51">UnsignedMin</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:ac8391e7d9d613a6c401787d2cdab1f51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe comparison of values that could be negative and incorrectly promoted.  <br /></td></tr>
<tr class="separator:ac8391e7d9d613a6c401787d2cdab1f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a2ce94589bb74164d809f4675bd23dd" id="r_a8a2ce94589bb74164d809f4675bd23dd"><td class="memTemplParams" colspan="2">template&lt;class T1, class T2&gt; </td></tr>
<tr class="memitem:a8a2ce94589bb74164d809f4675bd23dd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8a2ce94589bb74164d809f4675bd23dd">SafeConvert</a> (T1 from, T2 &amp;to)</td></tr>
<tr class="memdesc:a8a2ce94589bb74164d809f4675bd23dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a conversion from <code class="param">from</code> to <code class="param">to</code>.  <br /></td></tr>
<tr class="separator:a8a2ce94589bb74164d809f4675bd23dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef9c6fb182e29b6f83218f0277b814ce" id="r_aef9c6fb182e29b6f83218f0277b814ce"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aef9c6fb182e29b6f83218f0277b814ce"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aef9c6fb182e29b6f83218f0277b814ce">SafeConvert</a> (sword64 from, word64 &amp;to)</td></tr>
<tr class="memdesc:aef9c6fb182e29b6f83218f0277b814ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a conversion from <code class="param">from</code> to <code class="param">to</code>.  <br /></td></tr>
<tr class="separator:aef9c6fb182e29b6f83218f0277b814ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7808d89c7ac5c2c77360944dc7369678" id="r_a7808d89c7ac5c2c77360944dc7369678"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a7808d89c7ac5c2c77360944dc7369678"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7808d89c7ac5c2c77360944dc7369678">SafeConvert</a> (<a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a> from, word64 &amp;to)</td></tr>
<tr class="memdesc:a7808d89c7ac5c2c77360944dc7369678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a conversion from <code class="param">from</code> to <code class="param">to</code>.  <br /></td></tr>
<tr class="separator:a7808d89c7ac5c2c77360944dc7369678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0052b1609559f5e113905d54d429711a" id="r_a0052b1609559f5e113905d54d429711a"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a0052b1609559f5e113905d54d429711a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0052b1609559f5e113905d54d429711a">SafeConvert</a> (<a class="el" href="config__int_8h.html#a3304866b527056436d1a444813cd5f6d">sword32</a> from, word64 &amp;to)</td></tr>
<tr class="memdesc:a0052b1609559f5e113905d54d429711a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a conversion from <code class="param">from</code> to <code class="param">to</code>.  <br /></td></tr>
<tr class="separator:a0052b1609559f5e113905d54d429711a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b7e594dd086ec2ae625cbcf7fe71b5f" id="r_a9b7e594dd086ec2ae625cbcf7fe71b5f"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a9b7e594dd086ec2ae625cbcf7fe71b5f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9b7e594dd086ec2ae625cbcf7fe71b5f">SafeConvert</a> (word64 from, sword64 &amp;to)</td></tr>
<tr class="memdesc:a9b7e594dd086ec2ae625cbcf7fe71b5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a conversion from <code class="param">from</code> to <code class="param">to</code>.  <br /></td></tr>
<tr class="separator:a9b7e594dd086ec2ae625cbcf7fe71b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d868daec4a6485ea8393ed87202db2e" id="r_a3d868daec4a6485ea8393ed87202db2e"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a3d868daec4a6485ea8393ed87202db2e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3d868daec4a6485ea8393ed87202db2e">SafeConvert</a> (<a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a> from, sword64 &amp;to)</td></tr>
<tr class="memdesc:a3d868daec4a6485ea8393ed87202db2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a conversion from <code class="param">from</code> to <code class="param">to</code>.  <br /></td></tr>
<tr class="separator:a3d868daec4a6485ea8393ed87202db2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a9752786a04193c6219f18b02050bb" id="r_ad0a9752786a04193c6219f18b02050bb"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ad0a9752786a04193c6219f18b02050bb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad0a9752786a04193c6219f18b02050bb">SafeConvert</a> (<a class="el" href="config__int_8h.html#a3304866b527056436d1a444813cd5f6d">sword32</a> from, sword64 &amp;to)</td></tr>
<tr class="memdesc:ad0a9752786a04193c6219f18b02050bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a conversion from <code class="param">from</code> to <code class="param">to</code>.  <br /></td></tr>
<tr class="separator:ad0a9752786a04193c6219f18b02050bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7c1d152be686ca1f2e017d226915468" id="r_ac7c1d152be686ca1f2e017d226915468"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ac7c1d152be686ca1f2e017d226915468"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac7c1d152be686ca1f2e017d226915468">SafeConvert</a> (word64 from, <a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a> &amp;to)</td></tr>
<tr class="memdesc:ac7c1d152be686ca1f2e017d226915468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a conversion from <code class="param">from</code> to <code class="param">to</code>.  <br /></td></tr>
<tr class="separator:ac7c1d152be686ca1f2e017d226915468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dbe71bd3d318f5b7be175b3f2997208" id="r_a9dbe71bd3d318f5b7be175b3f2997208"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a9dbe71bd3d318f5b7be175b3f2997208"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9dbe71bd3d318f5b7be175b3f2997208">SafeConvert</a> (sword64 from, <a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a> &amp;to)</td></tr>
<tr class="memdesc:a9dbe71bd3d318f5b7be175b3f2997208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a conversion from <code class="param">from</code> to <code class="param">to</code>.  <br /></td></tr>
<tr class="separator:a9dbe71bd3d318f5b7be175b3f2997208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a051380375fe085115451a06b84d68c3d" id="r_a051380375fe085115451a06b84d68c3d"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a051380375fe085115451a06b84d68c3d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a051380375fe085115451a06b84d68c3d">SafeConvert</a> (<a class="el" href="config__int_8h.html#a3304866b527056436d1a444813cd5f6d">sword32</a> from, <a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a> &amp;to)</td></tr>
<tr class="memdesc:a051380375fe085115451a06b84d68c3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a conversion from <code class="param">from</code> to <code class="param">to</code>.  <br /></td></tr>
<tr class="separator:a051380375fe085115451a06b84d68c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb7c3d4c147bee46750037a346059815" id="r_adb7c3d4c147bee46750037a346059815"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:adb7c3d4c147bee46750037a346059815"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adb7c3d4c147bee46750037a346059815">SafeConvert</a> (word64 from, <a class="el" href="config__int_8h.html#a3304866b527056436d1a444813cd5f6d">sword32</a> &amp;to)</td></tr>
<tr class="memdesc:adb7c3d4c147bee46750037a346059815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a conversion from <code class="param">from</code> to <code class="param">to</code>.  <br /></td></tr>
<tr class="separator:adb7c3d4c147bee46750037a346059815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66c8abb585a36d6117ce1c29c54aeab2" id="r_a66c8abb585a36d6117ce1c29c54aeab2"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a66c8abb585a36d6117ce1c29c54aeab2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a66c8abb585a36d6117ce1c29c54aeab2">SafeConvert</a> (sword64 from, <a class="el" href="config__int_8h.html#a3304866b527056436d1a444813cd5f6d">sword32</a> &amp;to)</td></tr>
<tr class="memdesc:a66c8abb585a36d6117ce1c29c54aeab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a conversion from <code class="param">from</code> to <code class="param">to</code>.  <br /></td></tr>
<tr class="separator:a66c8abb585a36d6117ce1c29c54aeab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45edf61e9d5dae4e1062d29d9059297b" id="r_a45edf61e9d5dae4e1062d29d9059297b"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a45edf61e9d5dae4e1062d29d9059297b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a45edf61e9d5dae4e1062d29d9059297b">SafeConvert</a> (<a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a> from, <a class="el" href="config__int_8h.html#a3304866b527056436d1a444813cd5f6d">sword32</a> &amp;to)</td></tr>
<tr class="memdesc:a45edf61e9d5dae4e1062d29d9059297b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a conversion from <code class="param">from</code> to <code class="param">to</code>.  <br /></td></tr>
<tr class="separator:a45edf61e9d5dae4e1062d29d9059297b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd7decd035cc4e144cd3d395e834106" id="r_a6cd7decd035cc4e144cd3d395e834106"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:a6cd7decd035cc4e144cd3d395e834106"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6cd7decd035cc4e144cd3d395e834106">IntToString</a> (T value, unsigned int base=10)</td></tr>
<tr class="memdesc:a6cd7decd035cc4e144cd3d395e834106"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a value to a string.  <br /></td></tr>
<tr class="separator:a6cd7decd035cc4e144cd3d395e834106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad4f4608b867f01a4cad90c5b222f89b" id="r_aad4f4608b867f01a4cad90c5b222f89b"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aad4f4608b867f01a4cad90c5b222f89b"><td class="memTemplItemLeft" align="right" valign="top">CRYPTOPP_DLL std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aad4f4608b867f01a4cad90c5b222f89b">IntToString&lt; word64 &gt;</a> (word64 value, unsigned int base)</td></tr>
<tr class="memdesc:aad4f4608b867f01a4cad90c5b222f89b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an unsigned value to a string.  <br /></td></tr>
<tr class="separator:aad4f4608b867f01a4cad90c5b222f89b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b67e971e2ab82125e3cf2a08a24a103" id="r_a1b67e971e2ab82125e3cf2a08a24a103"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a1b67e971e2ab82125e3cf2a08a24a103"><td class="memTemplItemLeft" align="right" valign="top">CRYPTOPP_DLL std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1b67e971e2ab82125e3cf2a08a24a103">IntToString&lt; Integer &gt;</a> (<a class="el" href="class_integer.html">Integer</a> value, unsigned int base)</td></tr>
<tr class="memdesc:a1b67e971e2ab82125e3cf2a08a24a103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an <a class="el" href="class_integer.html" title="Multiple precision integer with arithmetic operations.">Integer</a> to a string.  <br /></td></tr>
<tr class="separator:a1b67e971e2ab82125e3cf2a08a24a103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c63a5683602db0ff8975746a414797f" id="r_a6c63a5683602db0ff8975746a414797f"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:a6c63a5683602db0ff8975746a414797f"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6c63a5683602db0ff8975746a414797f">Parity</a> (T value)</td></tr>
<tr class="memdesc:a6c63a5683602db0ff8975746a414797f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the parity of a value.  <br /></td></tr>
<tr class="separator:a6c63a5683602db0ff8975746a414797f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e22fbd4b8f95aa01bde93ea32e44e82" id="r_a3e22fbd4b8f95aa01bde93ea32e44e82"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:a3e22fbd4b8f95aa01bde93ea32e44e82"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3e22fbd4b8f95aa01bde93ea32e44e82">BytePrecision</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a3e22fbd4b8f95aa01bde93ea32e44e82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of 8-bit bytes or octets required for a value.  <br /></td></tr>
<tr class="separator:a3e22fbd4b8f95aa01bde93ea32e44e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5964768bc94670ad2bc3f218d9367f" id="r_a3c5964768bc94670ad2bc3f218d9367f"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:a3c5964768bc94670ad2bc3f218d9367f"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3c5964768bc94670ad2bc3f218d9367f">BitPrecision</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a3c5964768bc94670ad2bc3f218d9367f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bits required for a value.  <br /></td></tr>
<tr class="separator:a3c5964768bc94670ad2bc3f218d9367f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a495acbd6f3cdabbb4dd863c09b378df4" id="r_a495acbd6f3cdabbb4dd863c09b378df4"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a495acbd6f3cdabbb4dd863c09b378df4">TrailingZeros</a> (<a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a> v)</td></tr>
<tr class="separator:a495acbd6f3cdabbb4dd863c09b378df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb4df9b2f1e119d89a1573338c4eda6" id="r_addb4df9b2f1e119d89a1573338c4eda6"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#addb4df9b2f1e119d89a1573338c4eda6">TrailingZeros</a> (word64 v)</td></tr>
<tr class="separator:addb4df9b2f1e119d89a1573338c4eda6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a616a7f0365c4947b0c8a44606c525a62" id="r_a616a7f0365c4947b0c8a44606c525a62"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:a616a7f0365c4947b0c8a44606c525a62"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a616a7f0365c4947b0c8a44606c525a62">Crop</a> (T value, size_t bits)</td></tr>
<tr class="memdesc:a616a7f0365c4947b0c8a44606c525a62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncates the value to the specified number of bits.  <br /></td></tr>
<tr class="separator:a616a7f0365c4947b0c8a44606c525a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c5d30b17c9d4869fdc3458dd05c500d" id="r_a7c5d30b17c9d4869fdc3458dd05c500d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c5d30b17c9d4869fdc3458dd05c500d">BitsToBytes</a> (size_t bitCount)</td></tr>
<tr class="memdesc:a7c5d30b17c9d4869fdc3458dd05c500d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of 8-bit bytes or octets required for the specified number of bits.  <br /></td></tr>
<tr class="separator:a7c5d30b17c9d4869fdc3458dd05c500d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a886cc7ce76578c6df939f564f676e71a" id="r_a886cc7ce76578c6df939f564f676e71a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a886cc7ce76578c6df939f564f676e71a">BytesToWords</a> (size_t byteCount)</td></tr>
<tr class="memdesc:a886cc7ce76578c6df939f564f676e71a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of words required for the specified number of bytes.  <br /></td></tr>
<tr class="separator:a886cc7ce76578c6df939f564f676e71a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c56601a8c94b6a37a21657929fe928" id="r_a45c56601a8c94b6a37a21657929fe928"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45c56601a8c94b6a37a21657929fe928">BitsToWords</a> (size_t bitCount)</td></tr>
<tr class="memdesc:a45c56601a8c94b6a37a21657929fe928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of words required for the specified number of bits.  <br /></td></tr>
<tr class="separator:a45c56601a8c94b6a37a21657929fe928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778d13f3d45915e1bc5c0ab1801ea6ad" id="r_a778d13f3d45915e1bc5c0ab1801ea6ad"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a778d13f3d45915e1bc5c0ab1801ea6ad">BitsToDwords</a> (size_t bitCount)</td></tr>
<tr class="memdesc:a778d13f3d45915e1bc5c0ab1801ea6ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of double words required for the specified number of bits.  <br /></td></tr>
<tr class="separator:a778d13f3d45915e1bc5c0ab1801ea6ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d2088e041288c140d06e1fba844e6e9" id="r_a7d2088e041288c140d06e1fba844e6e9"><td class="memItemLeft" align="right" valign="top">CRYPTOPP_DLL void CRYPTOPP_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d2088e041288c140d06e1fba844e6e9">xorbuf</a> (<a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *buf, const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *mask, size_t count)</td></tr>
<tr class="separator:a7d2088e041288c140d06e1fba844e6e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4db8a951de8dbc133bc845e21d2c59ae" id="r_a4db8a951de8dbc133bc845e21d2c59ae"><td class="memItemLeft" align="right" valign="top">CRYPTOPP_DLL void CRYPTOPP_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4db8a951de8dbc133bc845e21d2c59ae">xorbuf</a> (<a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *output, const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *input, const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *mask, size_t count)</td></tr>
<tr class="separator:a4db8a951de8dbc133bc845e21d2c59ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f1c626f8d491a96c517b5a165b60be5" id="r_a9f1c626f8d491a96c517b5a165b60be5"><td class="memItemLeft" align="right" valign="top">CRYPTOPP_DLL bool CRYPTOPP_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f1c626f8d491a96c517b5a165b60be5">VerifyBufsEqual</a> (const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *buf1, const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *buf2, size_t count)</td></tr>
<tr class="memdesc:a9f1c626f8d491a96c517b5a165b60be5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a near constant-time comparison of two equally sized buffers.  <br /></td></tr>
<tr class="separator:a9f1c626f8d491a96c517b5a165b60be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65531618a7eca8803fa9e9287c43aafc" id="r_a65531618a7eca8803fa9e9287c43aafc"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:a65531618a7eca8803fa9e9287c43aafc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a65531618a7eca8803fa9e9287c43aafc">IsPowerOf2</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a65531618a7eca8803fa9e9287c43aafc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether a value is a power of 2.  <br /></td></tr>
<tr class="separator:a65531618a7eca8803fa9e9287c43aafc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67b8be26ba8900662fa86dcea6d831f9" id="r_a67b8be26ba8900662fa86dcea6d831f9"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:a67b8be26ba8900662fa86dcea6d831f9"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a67b8be26ba8900662fa86dcea6d831f9">NumericLimitsMin</a> ()</td></tr>
<tr class="memdesc:a67b8be26ba8900662fa86dcea6d831f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide the minimum value for a type.  <br /></td></tr>
<tr class="separator:a67b8be26ba8900662fa86dcea6d831f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39f468338a6ad6a22fa0e9c16819fa7" id="r_af39f468338a6ad6a22fa0e9c16819fa7"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:af39f468338a6ad6a22fa0e9c16819fa7"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af39f468338a6ad6a22fa0e9c16819fa7">NumericLimitsMax</a> ()</td></tr>
<tr class="memdesc:af39f468338a6ad6a22fa0e9c16819fa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide the maximum value for a type.  <br /></td></tr>
<tr class="separator:af39f468338a6ad6a22fa0e9c16819fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30712a90999ad9d9152975f2e92d46b8" id="r_a30712a90999ad9d9152975f2e92d46b8"><td class="memTemplParams" colspan="2">template&lt;class T1, class T2&gt; </td></tr>
<tr class="memitem:a30712a90999ad9d9152975f2e92d46b8"><td class="memTemplItemLeft" align="right" valign="top">T1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a30712a90999ad9d9152975f2e92d46b8">SaturatingSubtract</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:a30712a90999ad9d9152975f2e92d46b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a saturating subtract clamped at 0.  <br /></td></tr>
<tr class="separator:a30712a90999ad9d9152975f2e92d46b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd39d67faef904dbb474981762b7ebe1" id="r_afd39d67faef904dbb474981762b7ebe1"><td class="memTemplParams" colspan="2">template&lt;class T1, class T2&gt; </td></tr>
<tr class="memitem:afd39d67faef904dbb474981762b7ebe1"><td class="memTemplItemLeft" align="right" valign="top">T1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afd39d67faef904dbb474981762b7ebe1">SaturatingSubtract1</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:afd39d67faef904dbb474981762b7ebe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a saturating subtract clamped at 1.  <br /></td></tr>
<tr class="separator:afd39d67faef904dbb474981762b7ebe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a621695f6346d6a745e340513d917b31a" id="r_a621695f6346d6a745e340513d917b31a"><td class="memTemplParams" colspan="2">template&lt;class T1, class T2&gt; </td></tr>
<tr class="memitem:a621695f6346d6a745e340513d917b31a"><td class="memTemplItemLeft" align="right" valign="top">T2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a621695f6346d6a745e340513d917b31a">ModPowerOf2</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:a621695f6346d6a745e340513d917b31a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduces a value to a power of 2.  <br /></td></tr>
<tr class="separator:a621695f6346d6a745e340513d917b31a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ac57210cb6796eced074e6d2e294fb" id="r_aa2ac57210cb6796eced074e6d2e294fb"><td class="memTemplParams" colspan="2">template&lt;class T1, class T2&gt; </td></tr>
<tr class="memitem:aa2ac57210cb6796eced074e6d2e294fb"><td class="memTemplItemLeft" align="right" valign="top">T1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa2ac57210cb6796eced074e6d2e294fb">RoundDownToMultipleOf</a> (const T1 &amp;n, const T2 &amp;m)</td></tr>
<tr class="memdesc:aa2ac57210cb6796eced074e6d2e294fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds a value down to a multiple of a second value.  <br /></td></tr>
<tr class="separator:aa2ac57210cb6796eced074e6d2e294fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a219d44f45272a1f3b3f17a656000a" id="r_a57a219d44f45272a1f3b3f17a656000a"><td class="memTemplParams" colspan="2">template&lt;class T1, class T2&gt; </td></tr>
<tr class="memitem:a57a219d44f45272a1f3b3f17a656000a"><td class="memTemplItemLeft" align="right" valign="top">T1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a57a219d44f45272a1f3b3f17a656000a">RoundUpToMultipleOf</a> (const T1 &amp;n, const T2 &amp;m)</td></tr>
<tr class="memdesc:a57a219d44f45272a1f3b3f17a656000a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds a value up to a multiple of a second value.  <br /></td></tr>
<tr class="separator:a57a219d44f45272a1f3b3f17a656000a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4e438054095c88f0c4d9eda7efc584d" id="r_ab4e438054095c88f0c4d9eda7efc584d"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:ab4e438054095c88f0c4d9eda7efc584d"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab4e438054095c88f0c4d9eda7efc584d">GetAlignmentOf</a> ()</td></tr>
<tr class="memdesc:ab4e438054095c88f0c4d9eda7efc584d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum alignment requirements of a type.  <br /></td></tr>
<tr class="separator:ab4e438054095c88f0c4d9eda7efc584d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a726c3b76265182681f5d5fd173ab5676" id="r_a726c3b76265182681f5d5fd173ab5676"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a726c3b76265182681f5d5fd173ab5676">IsAlignedOn</a> (const void *ptr, unsigned int alignment)</td></tr>
<tr class="memdesc:a726c3b76265182681f5d5fd173ab5676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether ptr is aligned to a minimum value.  <br /></td></tr>
<tr class="separator:a726c3b76265182681f5d5fd173ab5676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b2c95659d16a971941622625c9102ae" id="r_a8b2c95659d16a971941622625c9102ae"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:a8b2c95659d16a971941622625c9102ae"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8b2c95659d16a971941622625c9102ae">IsAligned</a> (const void *ptr)</td></tr>
<tr class="memdesc:a8b2c95659d16a971941622625c9102ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether ptr is minimally aligned.  <br /></td></tr>
<tr class="separator:a8b2c95659d16a971941622625c9102ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8336b0d98f2469441837be6cbbebf9" id="r_aed8336b0d98f2469441837be6cbbebf9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed8336b0d98f2469441837be6cbbebf9">GetNativeByteOrder</a> ()</td></tr>
<tr class="memdesc:aed8336b0d98f2469441837be6cbbebf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns NativeByteOrder as an enumerated <a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b" title="Provides the byte ordering.">ByteOrder</a> value.  <br /></td></tr>
<tr class="separator:aed8336b0d98f2469441837be6cbbebf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c2da0dd866619761e63c3b5da58c477" id="r_a6c2da0dd866619761e63c3b5da58c477"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c2da0dd866619761e63c3b5da58c477">NativeByteOrderIs</a> (<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order)</td></tr>
<tr class="memdesc:a6c2da0dd866619761e63c3b5da58c477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether order follows native byte ordering.  <br /></td></tr>
<tr class="separator:a6c2da0dd866619761e63c3b5da58c477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade22f7ed542b3db2912c917f8e3d6067" id="r_ade22f7ed542b3db2912c917f8e3d6067"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:ade22f7ed542b3db2912c917f8e3d6067"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="cryptlib_8h.html#a353ccabf5ddc119a6a33e92f7b9961c7">CipherDir</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ade22f7ed542b3db2912c917f8e3d6067">GetCipherDir</a> (const T &amp;obj)</td></tr>
<tr class="memdesc:ade22f7ed542b3db2912c917f8e3d6067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the direction the cipher is being operated.  <br /></td></tr>
<tr class="separator:ade22f7ed542b3db2912c917f8e3d6067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44fad9d8c25e8aca3a7ee29345516f0a" id="r_a44fad9d8c25e8aca3a7ee29345516f0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44fad9d8c25e8aca3a7ee29345516f0a">IncrementCounterByOne</a> (<a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *inout, unsigned int size)</td></tr>
<tr class="memdesc:a44fad9d8c25e8aca3a7ee29345516f0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an addition with carry on a block of bytes.  <br /></td></tr>
<tr class="separator:a44fad9d8c25e8aca3a7ee29345516f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f852960b51e106a849781341cb2055c" id="r_a2f852960b51e106a849781341cb2055c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f852960b51e106a849781341cb2055c">IncrementCounterByOne</a> (<a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *output, const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *input, unsigned int size)</td></tr>
<tr class="memdesc:a2f852960b51e106a849781341cb2055c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an addition with carry on a block of bytes.  <br /></td></tr>
<tr class="separator:a2f852960b51e106a849781341cb2055c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae71e5659910553da22f9b1e877cddc07" id="r_ae71e5659910553da22f9b1e877cddc07"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:ae71e5659910553da22f9b1e877cddc07"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae71e5659910553da22f9b1e877cddc07">ConditionalSwap</a> (bool c, T &amp;a, T &amp;b)</td></tr>
<tr class="memdesc:ae71e5659910553da22f9b1e877cddc07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a branch-less swap of values a and b if condition c is true.  <br /></td></tr>
<tr class="separator:ae71e5659910553da22f9b1e877cddc07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a513e4522b268f9ee2e188606c2101d5a" id="r_a513e4522b268f9ee2e188606c2101d5a"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:a513e4522b268f9ee2e188606c2101d5a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a513e4522b268f9ee2e188606c2101d5a">ConditionalSwapPointers</a> (bool c, T &amp;a, T &amp;b)</td></tr>
<tr class="memdesc:a513e4522b268f9ee2e188606c2101d5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a branch-less swap of pointers a and b if condition c is true.  <br /></td></tr>
<tr class="separator:a513e4522b268f9ee2e188606c2101d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a656f38b8d0440981f5f013ada782018c" id="r_a656f38b8d0440981f5f013ada782018c"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:a656f38b8d0440981f5f013ada782018c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a656f38b8d0440981f5f013ada782018c">SecureWipeBuffer</a> (T *buf, size_t n)</td></tr>
<tr class="memdesc:a656f38b8d0440981f5f013ada782018c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets each element of an array to 0.  <br /></td></tr>
<tr class="separator:a656f38b8d0440981f5f013ada782018c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4994f3480634e5f1435fd71f9b652c38" id="r_a4994f3480634e5f1435fd71f9b652c38"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:a4994f3480634e5f1435fd71f9b652c38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4994f3480634e5f1435fd71f9b652c38">SecureWipeArray</a> (T *buf, size_t n)</td></tr>
<tr class="memdesc:a4994f3480634e5f1435fd71f9b652c38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets each element of an array to 0.  <br /></td></tr>
<tr class="separator:a4994f3480634e5f1435fd71f9b652c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba2ed56f8a15d6dabbef74390eda4352" id="r_aba2ed56f8a15d6dabbef74390eda4352"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba2ed56f8a15d6dabbef74390eda4352">StringNarrow</a> (const wchar_t *str, bool throwOnError=true)</td></tr>
<tr class="memdesc:aba2ed56f8a15d6dabbef74390eda4352"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a wide character C-string to a multibyte string.  <br /></td></tr>
<tr class="separator:aba2ed56f8a15d6dabbef74390eda4352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac95ff706a83782e3d18a3d14817db932" id="r_ac95ff706a83782e3d18a3d14817db932"><td class="memItemLeft" align="right" valign="top">std::wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac95ff706a83782e3d18a3d14817db932">StringWiden</a> (const char *str, bool throwOnError=true)</td></tr>
<tr class="memdesc:ac95ff706a83782e3d18a3d14817db932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a multibyte C-string to a wide character string.  <br /></td></tr>
<tr class="separator:ac95ff706a83782e3d18a3d14817db932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ab6928faa40f6e56e7f4817d5d65a38" id="r_a0ab6928faa40f6e56e7f4817d5d65a38"><td class="memTemplParams" colspan="2">template&lt;unsigned int R, class T&gt; </td></tr>
<tr class="memitem:a0ab6928faa40f6e56e7f4817d5d65a38"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0ab6928faa40f6e56e7f4817d5d65a38">rotlConstant</a> (T x)</td></tr>
<tr class="memdesc:a0ab6928faa40f6e56e7f4817d5d65a38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a left rotate.  <br /></td></tr>
<tr class="separator:a0ab6928faa40f6e56e7f4817d5d65a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d777068849add4c7ab87f7b0683ef65" id="r_a7d777068849add4c7ab87f7b0683ef65"><td class="memTemplParams" colspan="2">template&lt;unsigned int R, class T&gt; </td></tr>
<tr class="memitem:a7d777068849add4c7ab87f7b0683ef65"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7d777068849add4c7ab87f7b0683ef65">rotrConstant</a> (T x)</td></tr>
<tr class="memdesc:a7d777068849add4c7ab87f7b0683ef65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a right rotate.  <br /></td></tr>
<tr class="separator:a7d777068849add4c7ab87f7b0683ef65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf7b80a08d25ab9d62693c9e4798ef98" id="r_aaf7b80a08d25ab9d62693c9e4798ef98"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:aaf7b80a08d25ab9d62693c9e4798ef98"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aaf7b80a08d25ab9d62693c9e4798ef98">rotlFixed</a> (T x, unsigned int y)</td></tr>
<tr class="memdesc:aaf7b80a08d25ab9d62693c9e4798ef98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a left rotate.  <br /></td></tr>
<tr class="separator:aaf7b80a08d25ab9d62693c9e4798ef98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf88e95400925b89c94641916535b6da" id="r_abf88e95400925b89c94641916535b6da"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:abf88e95400925b89c94641916535b6da"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abf88e95400925b89c94641916535b6da">rotrFixed</a> (T x, unsigned int y)</td></tr>
<tr class="memdesc:abf88e95400925b89c94641916535b6da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a right rotate.  <br /></td></tr>
<tr class="separator:abf88e95400925b89c94641916535b6da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0de05253683b27a221e6465b3a7453b2" id="r_a0de05253683b27a221e6465b3a7453b2"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:a0de05253683b27a221e6465b3a7453b2"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0de05253683b27a221e6465b3a7453b2">rotlVariable</a> (T x, unsigned int y)</td></tr>
<tr class="memdesc:a0de05253683b27a221e6465b3a7453b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a left rotate.  <br /></td></tr>
<tr class="separator:a0de05253683b27a221e6465b3a7453b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd053d245fe902fe55bfd8a335634110" id="r_abd053d245fe902fe55bfd8a335634110"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:abd053d245fe902fe55bfd8a335634110"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abd053d245fe902fe55bfd8a335634110">rotrVariable</a> (T x, unsigned int y)</td></tr>
<tr class="memdesc:abd053d245fe902fe55bfd8a335634110"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a right rotate.  <br /></td></tr>
<tr class="separator:abd053d245fe902fe55bfd8a335634110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad31fe5d559d014085c6a49594b817196" id="r_ad31fe5d559d014085c6a49594b817196"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:ad31fe5d559d014085c6a49594b817196"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad31fe5d559d014085c6a49594b817196">rotlMod</a> (T x, unsigned int y)</td></tr>
<tr class="memdesc:ad31fe5d559d014085c6a49594b817196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a left rotate.  <br /></td></tr>
<tr class="separator:ad31fe5d559d014085c6a49594b817196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8fc34eb834dd2424407d5e4d729594e" id="r_ae8fc34eb834dd2424407d5e4d729594e"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:ae8fc34eb834dd2424407d5e4d729594e"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae8fc34eb834dd2424407d5e4d729594e">rotrMod</a> (T x, unsigned int y)</td></tr>
<tr class="memdesc:ae8fc34eb834dd2424407d5e4d729594e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a right rotate.  <br /></td></tr>
<tr class="separator:ae8fc34eb834dd2424407d5e4d729594e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a2ceb73851e757cb436cdbaa0242219" id="r_a9a2ceb73851e757cb436cdbaa0242219"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:a9a2ceb73851e757cb436cdbaa0242219"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9a2ceb73851e757cb436cdbaa0242219">GetByte</a> (<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order, T value, unsigned int index)</td></tr>
<tr class="memdesc:a9a2ceb73851e757cb436cdbaa0242219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a byte from a value.  <br /></td></tr>
<tr class="separator:a9a2ceb73851e757cb436cdbaa0242219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d8d5adca8384ebedc699760ce217b08" id="r_a1d8d5adca8384ebedc699760ce217b08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d8d5adca8384ebedc699760ce217b08">ByteReverse</a> (<a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> value)</td></tr>
<tr class="memdesc:a1d8d5adca8384ebedc699760ce217b08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses bytes in a 8-bit value.  <br /></td></tr>
<tr class="separator:a1d8d5adca8384ebedc699760ce217b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa179e009cf5c74bb431b3c112d7ee444" id="r_aa179e009cf5c74bb431b3c112d7ee444"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config__int_8h.html#ac32ea9831f54b53dfce00081c0d02681">word16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa179e009cf5c74bb431b3c112d7ee444">ByteReverse</a> (<a class="el" href="config__int_8h.html#ac32ea9831f54b53dfce00081c0d02681">word16</a> value)</td></tr>
<tr class="memdesc:aa179e009cf5c74bb431b3c112d7ee444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses bytes in a 16-bit value.  <br /></td></tr>
<tr class="separator:aa179e009cf5c74bb431b3c112d7ee444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf65f4a9edb6224d01e900aa7205a4f4" id="r_acf65f4a9edb6224d01e900aa7205a4f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf65f4a9edb6224d01e900aa7205a4f4">ByteReverse</a> (<a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a> value)</td></tr>
<tr class="memdesc:acf65f4a9edb6224d01e900aa7205a4f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses bytes in a 32-bit value.  <br /></td></tr>
<tr class="separator:acf65f4a9edb6224d01e900aa7205a4f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47686f3b4957541a58a3b280d1a89d4c" id="r_a47686f3b4957541a58a3b280d1a89d4c"><td class="memItemLeft" align="right" valign="top">word64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47686f3b4957541a58a3b280d1a89d4c">ByteReverse</a> (word64 value)</td></tr>
<tr class="memdesc:a47686f3b4957541a58a3b280d1a89d4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses bytes in a 64-bit value.  <br /></td></tr>
<tr class="separator:a47686f3b4957541a58a3b280d1a89d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1746e70bf831f0cbf8ad73d8c15bc921" id="r_a1746e70bf831f0cbf8ad73d8c15bc921"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1746e70bf831f0cbf8ad73d8c15bc921">BitReverse</a> (<a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> value)</td></tr>
<tr class="memdesc:a1746e70bf831f0cbf8ad73d8c15bc921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses bits in a 8-bit value.  <br /></td></tr>
<tr class="separator:a1746e70bf831f0cbf8ad73d8c15bc921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a699c24d7013f20ee03076576984c875e" id="r_a699c24d7013f20ee03076576984c875e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config__int_8h.html#ac32ea9831f54b53dfce00081c0d02681">word16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a699c24d7013f20ee03076576984c875e">BitReverse</a> (<a class="el" href="config__int_8h.html#ac32ea9831f54b53dfce00081c0d02681">word16</a> value)</td></tr>
<tr class="memdesc:a699c24d7013f20ee03076576984c875e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses bits in a 16-bit value.  <br /></td></tr>
<tr class="separator:a699c24d7013f20ee03076576984c875e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad87ebeafa7de2c11c19453f3b3cfea7" id="r_aad87ebeafa7de2c11c19453f3b3cfea7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad87ebeafa7de2c11c19453f3b3cfea7">BitReverse</a> (<a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a> value)</td></tr>
<tr class="memdesc:aad87ebeafa7de2c11c19453f3b3cfea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses bits in a 32-bit value.  <br /></td></tr>
<tr class="separator:aad87ebeafa7de2c11c19453f3b3cfea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a336c0289dcd2670e6b4079fa98018d7a" id="r_a336c0289dcd2670e6b4079fa98018d7a"><td class="memItemLeft" align="right" valign="top">word64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a336c0289dcd2670e6b4079fa98018d7a">BitReverse</a> (word64 value)</td></tr>
<tr class="memdesc:a336c0289dcd2670e6b4079fa98018d7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses bits in a 64-bit value.  <br /></td></tr>
<tr class="separator:a336c0289dcd2670e6b4079fa98018d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a641ecc1d620ac8c04bc43661a2bbba71" id="r_a641ecc1d620ac8c04bc43661a2bbba71"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:a641ecc1d620ac8c04bc43661a2bbba71"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a641ecc1d620ac8c04bc43661a2bbba71">BitReverse</a> (T value)</td></tr>
<tr class="memdesc:a641ecc1d620ac8c04bc43661a2bbba71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses bits in a value.  <br /></td></tr>
<tr class="separator:a641ecc1d620ac8c04bc43661a2bbba71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e499ded4f2e7e7705c3cfd39cdf137f" id="r_a8e499ded4f2e7e7705c3cfd39cdf137f"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:a8e499ded4f2e7e7705c3cfd39cdf137f"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8e499ded4f2e7e7705c3cfd39cdf137f">ConditionalByteReverse</a> (<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order, T value)</td></tr>
<tr class="memdesc:a8e499ded4f2e7e7705c3cfd39cdf137f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses bytes in a value depending upon endianness.  <br /></td></tr>
<tr class="separator:a8e499ded4f2e7e7705c3cfd39cdf137f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab95e030e0abd33ea360d75cd9c4c8bbe" id="r_ab95e030e0abd33ea360d75cd9c4c8bbe"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:ab95e030e0abd33ea360d75cd9c4c8bbe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab95e030e0abd33ea360d75cd9c4c8bbe">ByteReverse</a> (T *out, const T *in, size_t byteCount)</td></tr>
<tr class="memdesc:ab95e030e0abd33ea360d75cd9c4c8bbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses bytes in an element from an array of elements.  <br /></td></tr>
<tr class="separator:ab95e030e0abd33ea360d75cd9c4c8bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0de65c1758668440f71a8ff6534ad9" id="r_aae0de65c1758668440f71a8ff6534ad9"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:aae0de65c1758668440f71a8ff6534ad9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aae0de65c1758668440f71a8ff6534ad9">ConditionalByteReverse</a> (<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order, T *out, const T *in, size_t byteCount)</td></tr>
<tr class="memdesc:aae0de65c1758668440f71a8ff6534ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally reverses bytes in an element from an array of elements.  <br /></td></tr>
<tr class="separator:aae0de65c1758668440f71a8ff6534ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929e347e6efedee4099dac8b3956350e" id="r_a929e347e6efedee4099dac8b3956350e"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:a929e347e6efedee4099dac8b3956350e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a929e347e6efedee4099dac8b3956350e">GetUserKey</a> (<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order, T *out, size_t outlen, const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *in, size_t inlen)</td></tr>
<tr class="memdesc:a929e347e6efedee4099dac8b3956350e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy bytes in a buffer to an array of elements in big-endian order.  <br /></td></tr>
<tr class="separator:a929e347e6efedee4099dac8b3956350e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ded795b6a29f00d160d123480d279d" id="r_ab4ded795b6a29f00d160d123480d279d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4ded795b6a29f00d160d123480d279d">UnalignedGetWordNonTemplate</a> (<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order, const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *block, const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *unused)</td></tr>
<tr class="memdesc:ab4ded795b6a29f00d160d123480d279d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a byte from an unaligned buffer.  <br /></td></tr>
<tr class="separator:ab4ded795b6a29f00d160d123480d279d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30f251bbb592f2d1621d8c37dffcf8a" id="r_aa30f251bbb592f2d1621d8c37dffcf8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config__int_8h.html#ac32ea9831f54b53dfce00081c0d02681">word16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa30f251bbb592f2d1621d8c37dffcf8a">UnalignedGetWordNonTemplate</a> (<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order, const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *block, const <a class="el" href="config__int_8h.html#ac32ea9831f54b53dfce00081c0d02681">word16</a> *unused)</td></tr>
<tr class="memdesc:aa30f251bbb592f2d1621d8c37dffcf8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a <a class="el" href="config__int_8h.html#ac32ea9831f54b53dfce00081c0d02681" title="16-bit unsigned datatype">word16</a> from an unaligned buffer.  <br /></td></tr>
<tr class="separator:aa30f251bbb592f2d1621d8c37dffcf8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7c7e2905abe7b50b0c49f78ea7fcb71" id="r_ad7c7e2905abe7b50b0c49f78ea7fcb71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad7c7e2905abe7b50b0c49f78ea7fcb71">UnalignedGetWordNonTemplate</a> (<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order, const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *block, const <a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a> *unused)</td></tr>
<tr class="memdesc:ad7c7e2905abe7b50b0c49f78ea7fcb71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a <a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d" title="32-bit unsigned datatype">word32</a> from an unaligned buffer.  <br /></td></tr>
<tr class="separator:ad7c7e2905abe7b50b0c49f78ea7fcb71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d6f65b550c7f363ba6d36ab1f5323c5" id="r_a8d6f65b550c7f363ba6d36ab1f5323c5"><td class="memItemLeft" align="right" valign="top">word64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d6f65b550c7f363ba6d36ab1f5323c5">UnalignedGetWordNonTemplate</a> (<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order, const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *block, const word64 *unused)</td></tr>
<tr class="memdesc:a8d6f65b550c7f363ba6d36ab1f5323c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a word64 from an unaligned buffer.  <br /></td></tr>
<tr class="separator:a8d6f65b550c7f363ba6d36ab1f5323c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8184a77f9a4c8ffbda9622b1cee7a148" id="r_a8184a77f9a4c8ffbda9622b1cee7a148"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8184a77f9a4c8ffbda9622b1cee7a148">UnalignedbyteNonTemplate</a> (<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order, <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *block, <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> value, const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *xorBlock)</td></tr>
<tr class="memdesc:a8184a77f9a4c8ffbda9622b1cee7a148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a byte to an unaligned buffer.  <br /></td></tr>
<tr class="separator:a8184a77f9a4c8ffbda9622b1cee7a148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac26b43699857ac54a8f4624c89bb6ab9" id="r_ac26b43699857ac54a8f4624c89bb6ab9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac26b43699857ac54a8f4624c89bb6ab9">UnalignedbyteNonTemplate</a> (<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order, <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *block, <a class="el" href="config__int_8h.html#ac32ea9831f54b53dfce00081c0d02681">word16</a> value, const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *xorBlock)</td></tr>
<tr class="memdesc:ac26b43699857ac54a8f4624c89bb6ab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a <a class="el" href="config__int_8h.html#ac32ea9831f54b53dfce00081c0d02681" title="16-bit unsigned datatype">word16</a> to an unaligned buffer.  <br /></td></tr>
<tr class="separator:ac26b43699857ac54a8f4624c89bb6ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef9d0bbf3f776108244b5c36ff5041d5" id="r_aef9d0bbf3f776108244b5c36ff5041d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef9d0bbf3f776108244b5c36ff5041d5">UnalignedbyteNonTemplate</a> (<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order, <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *block, <a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a> value, const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *xorBlock)</td></tr>
<tr class="memdesc:aef9d0bbf3f776108244b5c36ff5041d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a <a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d" title="32-bit unsigned datatype">word32</a> to an unaligned buffer.  <br /></td></tr>
<tr class="separator:aef9d0bbf3f776108244b5c36ff5041d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36bf3fa1752839aa454537cd2d3ca935" id="r_a36bf3fa1752839aa454537cd2d3ca935"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36bf3fa1752839aa454537cd2d3ca935">UnalignedbyteNonTemplate</a> (<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order, <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *block, word64 value, const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *xorBlock)</td></tr>
<tr class="memdesc:a36bf3fa1752839aa454537cd2d3ca935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a word64 to an unaligned buffer.  <br /></td></tr>
<tr class="separator:a36bf3fa1752839aa454537cd2d3ca935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a240e8e97f964626508362b59b78532d3" id="r_a240e8e97f964626508362b59b78532d3"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:a240e8e97f964626508362b59b78532d3"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a240e8e97f964626508362b59b78532d3">GetWord</a> (bool assumeAligned, <a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order, const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *block)</td></tr>
<tr class="memdesc:a240e8e97f964626508362b59b78532d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access a block of memory.  <br /></td></tr>
<tr class="separator:a240e8e97f964626508362b59b78532d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4546cdeeecddedd3a0f784ea6b80c8bd" id="r_a4546cdeeecddedd3a0f784ea6b80c8bd"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:a4546cdeeecddedd3a0f784ea6b80c8bd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4546cdeeecddedd3a0f784ea6b80c8bd">GetWord</a> (bool assumeAligned, <a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order, T &amp;result, const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *block)</td></tr>
<tr class="memdesc:a4546cdeeecddedd3a0f784ea6b80c8bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access a block of memory.  <br /></td></tr>
<tr class="separator:a4546cdeeecddedd3a0f784ea6b80c8bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a096e90ab9bb746edf908d25f0856a786" id="r_a096e90ab9bb746edf908d25f0856a786"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:a096e90ab9bb746edf908d25f0856a786"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a096e90ab9bb746edf908d25f0856a786">PutWord</a> (bool assumeAligned, <a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order, <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *block, T value, const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *xorBlock=NULLPTR)</td></tr>
<tr class="memdesc:a096e90ab9bb746edf908d25f0856a786"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access a block of memory.  <br /></td></tr>
<tr class="separator:a096e90ab9bb746edf908d25f0856a786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a35b59a1f2e23b94ed2f74f0594613" id="r_a18a35b59a1f2e23b94ed2f74f0594613"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:a18a35b59a1f2e23b94ed2f74f0594613"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a18a35b59a1f2e23b94ed2f74f0594613">WordToString</a> (T value, <a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order=<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142baf0c3bb6c718cc7ff0bffef4e8f178c57">BIG_ENDIAN_ORDER</a>)</td></tr>
<tr class="memdesc:a18a35b59a1f2e23b94ed2f74f0594613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a word to a string.  <br /></td></tr>
<tr class="separator:a18a35b59a1f2e23b94ed2f74f0594613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23234e96107b28512db9467c33f67590" id="r_a23234e96107b28512db9467c33f67590"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:a23234e96107b28512db9467c33f67590"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a23234e96107b28512db9467c33f67590">StringToWord</a> (const std::string &amp;str, <a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order=<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142baf0c3bb6c718cc7ff0bffef4e8f178c57">BIG_ENDIAN_ORDER</a>)</td></tr>
<tr class="memdesc:a23234e96107b28512db9467c33f67590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string to a word.  <br /></td></tr>
<tr class="separator:a23234e96107b28512db9467c33f67590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda5071e4c754b612b6a4c42be421312" id="r_abda5071e4c754b612b6a4c42be421312"><td class="memTemplParams" colspan="2">template&lt;unsigned int bits, class T&gt; </td></tr>
<tr class="memitem:abda5071e4c754b612b6a4c42be421312"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abda5071e4c754b612b6a4c42be421312">SafeRightShift</a> (T value)</td></tr>
<tr class="memdesc:abda5071e4c754b612b6a4c42be421312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safely right shift values when undefined behavior could occur.  <br /></td></tr>
<tr class="separator:abda5071e4c754b612b6a4c42be421312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e2662974095094e345b2bc2b30ee4c" id="r_a45e2662974095094e345b2bc2b30ee4c"><td class="memTemplParams" colspan="2">template&lt;unsigned int bits, class T&gt; </td></tr>
<tr class="memitem:a45e2662974095094e345b2bc2b30ee4c"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a45e2662974095094e345b2bc2b30ee4c">SafeLeftShift</a> (T value)</td></tr>
<tr class="memdesc:a45e2662974095094e345b2bc2b30ee4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safely left shift values when undefined behavior could occur.  <br /></td></tr>
<tr class="separator:a45e2662974095094e345b2bc2b30ee4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab29e4cf4553b1ff9f884df223a2abd6a" id="r_ab29e4cf4553b1ff9f884df223a2abd6a"><td class="memTemplParams" colspan="2">template&lt;typename InputIt, typename T&gt; </td></tr>
<tr class="memitem:ab29e4cf4553b1ff9f884df223a2abd6a"><td class="memTemplItemLeft" align="right" valign="top">InputIt&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab29e4cf4553b1ff9f884df223a2abd6a">FindIfNot</a> (InputIt first, InputIt last, const T &amp;value)</td></tr>
<tr class="memdesc:ab29e4cf4553b1ff9f884df223a2abd6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds first element not in a range.  <br /></td></tr>
<tr class="separator:ab29e4cf4553b1ff9f884df223a2abd6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Utility functions for the Crypto++ library. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="acc2b6e8b1b96a4ed267a8cec32a92425" name="acc2b6e8b1b96a4ed267a8cec32a92425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc2b6e8b1b96a4ed267a8cec32a92425">&#9670;&#160;</a></span>COUNTOF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define COUNTOF</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(<span class="keyword">sizeof</span>(x)/<span class="keyword">sizeof</span>(x[0]))</div>
</div><!-- fragment -->
</div>
</div>
<a id="a687aa2e764e0e2f1f4649e68d9869a3b" name="a687aa2e764e0e2f1f4649e68d9869a3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a687aa2e764e0e2f1f4649e68d9869a3b">&#9670;&#160;</a></span>CRYPTOPP_ASSERT_JOIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRYPTOPP_ASSERT_JOIN</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>Y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">CRYPTOPP_DO_ASSERT_JOIN(X, Y)</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab44245f76e0fc08ab8ba76771ef3d9f5" name="ab44245f76e0fc08ab8ba76771ef3d9f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab44245f76e0fc08ab8ba76771ef3d9f5">&#9670;&#160;</a></span>CRYPTOPP_BLOCK_1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRYPTOPP_BLOCK_1</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">t* m_##n() {<span class="keywordflow">return</span> (t *)(<span class="keywordtype">void</span> *)(m_aggregate+0);}     <span class="keywordtype">size_t</span> SS1() {<span class="keywordflow">return</span>       <span class="keyword">sizeof</span>(t)*(s);} <span class="keywordtype">size_t</span> m_##n##Size() {<span class="keywordflow">return</span> (s);}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aca956e0abd7368e25cebeb9513616eca" name="aca956e0abd7368e25cebeb9513616eca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca956e0abd7368e25cebeb9513616eca">&#9670;&#160;</a></span>CRYPTOPP_BLOCK_2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRYPTOPP_BLOCK_2</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">t* m_##n() {<span class="keywordflow">return</span> (t *)(<span class="keywordtype">void</span> *)(m_aggregate+SS1());} <span class="keywordtype">size_t</span> SS2() {<span class="keywordflow">return</span> SS1()+<span class="keyword">sizeof</span>(t)*(s);} <span class="keywordtype">size_t</span> m_##n##Size() {<span class="keywordflow">return</span> (s);}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a48a4e24d34c37d65a379bd06a4bf12d2" name="a48a4e24d34c37d65a379bd06a4bf12d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48a4e24d34c37d65a379bd06a4bf12d2">&#9670;&#160;</a></span>CRYPTOPP_BLOCK_3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRYPTOPP_BLOCK_3</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">t* m_##n() {<span class="keywordflow">return</span> (t *)(<span class="keywordtype">void</span> *)(m_aggregate+SS2());} <span class="keywordtype">size_t</span> SS3() {<span class="keywordflow">return</span> SS2()+<span class="keyword">sizeof</span>(t)*(s);} <span class="keywordtype">size_t</span> m_##n##Size() {<span class="keywordflow">return</span> (s);}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5e8366a854dd78fbaba4da6ace69b3b4" name="a5e8366a854dd78fbaba4da6ace69b3b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e8366a854dd78fbaba4da6ace69b3b4">&#9670;&#160;</a></span>CRYPTOPP_BLOCK_4</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRYPTOPP_BLOCK_4</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">t* m_##n() {<span class="keywordflow">return</span> (t *)(<span class="keywordtype">void</span> *)(m_aggregate+SS3());} <span class="keywordtype">size_t</span> SS4() {<span class="keywordflow">return</span> SS3()+<span class="keyword">sizeof</span>(t)*(s);} <span class="keywordtype">size_t</span> m_##n##Size() {<span class="keywordflow">return</span> (s);}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3d00455e80e440dde3572996227bf0f0" name="a3d00455e80e440dde3572996227bf0f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d00455e80e440dde3572996227bf0f0">&#9670;&#160;</a></span>CRYPTOPP_BLOCK_5</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRYPTOPP_BLOCK_5</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">t* m_##n() {<span class="keywordflow">return</span> (t *)(<span class="keywordtype">void</span> *)(m_aggregate+SS4());} <span class="keywordtype">size_t</span> SS5() {<span class="keywordflow">return</span> SS4()+<span class="keyword">sizeof</span>(t)*(s);} <span class="keywordtype">size_t</span> m_##n##Size() {<span class="keywordflow">return</span> (s);}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a11940604e7e44c16170ab0bc89e4e8f6" name="a11940604e7e44c16170ab0bc89e4e8f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11940604e7e44c16170ab0bc89e4e8f6">&#9670;&#160;</a></span>CRYPTOPP_BLOCK_6</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRYPTOPP_BLOCK_6</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">t* m_##n() {<span class="keywordflow">return</span> (t *)(<span class="keywordtype">void</span> *)(m_aggregate+SS5());} <span class="keywordtype">size_t</span> SS6() {<span class="keywordflow">return</span> SS5()+<span class="keyword">sizeof</span>(t)*(s);} <span class="keywordtype">size_t</span> m_##n##Size() {<span class="keywordflow">return</span> (s);}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4fee2fd43faebed6eac61f1f3d8bc423" name="a4fee2fd43faebed6eac61f1f3d8bc423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fee2fd43faebed6eac61f1f3d8bc423">&#9670;&#160;</a></span>CRYPTOPP_BLOCK_7</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRYPTOPP_BLOCK_7</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">t* m_##n() {<span class="keywordflow">return</span> (t *)(<span class="keywordtype">void</span> *)(m_aggregate+SS6());} <span class="keywordtype">size_t</span> SS7() {<span class="keywordflow">return</span> SS6()+<span class="keyword">sizeof</span>(t)*(s);} <span class="keywordtype">size_t</span> m_##n##Size() {<span class="keywordflow">return</span> (s);}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4ac56e108366ccfa9c5ecf923b52e936" name="a4ac56e108366ccfa9c5ecf923b52e936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ac56e108366ccfa9c5ecf923b52e936">&#9670;&#160;</a></span>CRYPTOPP_BLOCK_8</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRYPTOPP_BLOCK_8</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">t* m_##n() {<span class="keywordflow">return</span> (t *)(<span class="keywordtype">void</span> *)(m_aggregate+SS7());} <span class="keywordtype">size_t</span> SS8() {<span class="keywordflow">return</span> SS7()+<span class="keyword">sizeof</span>(t)*(s);} <span class="keywordtype">size_t</span> m_##n##Size() {<span class="keywordflow">return</span> (s);}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ade27627ae9dfbc2bee30153a513e229c" name="ade27627ae9dfbc2bee30153a513e229c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade27627ae9dfbc2bee30153a513e229c">&#9670;&#160;</a></span>CRYPTOPP_BLOCKS_END</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRYPTOPP_BLOCKS_END</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordtype">size_t</span> SST() {<span class="keywordflow">return</span> SS##i();} <span class="keywordtype">void</span> AllocateBlocks() {m_aggregate.New(SST());} AlignedSecByteBlock m_aggregate;</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab07644575199e2dc5fa4eac13c3dea2e" name="ab07644575199e2dc5fa4eac13c3dea2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab07644575199e2dc5fa4eac13c3dea2e">&#9670;&#160;</a></span>CRYPTOPP_COMPILE_ASSERT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRYPTOPP_COMPILE_ASSERT</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>assertion</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">CRYPTOPP_COMPILE_ASSERT_INSTANCE(assertion, __LINE__)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4002b9b8cfe3baff72fc606a0525c2fe" name="a4002b9b8cfe3baff72fc606a0525c2fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4002b9b8cfe3baff72fc606a0525c2fe">&#9670;&#160;</a></span>CRYPTOPP_COMPILE_ASSERT_INSTANCE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRYPTOPP_COMPILE_ASSERT_INSTANCE</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>assertion</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>instance</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">       <span class="keyword">static</span> <a class="code hl_struct" href="struct_compile_assert.html">CompileAssert</a>&lt;(assertion)&gt; \</div>
<div class="line">       CRYPTOPP_ASSERT_JOIN(cryptopp_CRYPTOPP_ASSERT_, instance)</div>
<div class="ttc" id="astruct_compile_assert_html"><div class="ttname"><a href="struct_compile_assert.html">CompileAssert</a></div><div class="ttdef"><b>Definition</b> misc.h:159</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aed3676a29b97ad67ab9efc2682ef78d4" name="aed3676a29b97ad67ab9efc2682ef78d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed3676a29b97ad67ab9efc2682ef78d4">&#9670;&#160;</a></span>CRYPTOPP_DO_ASSERT_JOIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRYPTOPP_DO_ASSERT_JOIN</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>Y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">X##Y</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9c7136e2091dd0e0fb5d4e97010b8430" name="a9c7136e2091dd0e0fb5d4e97010b8430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c7136e2091dd0e0fb5d4e97010b8430">&#9670;&#160;</a></span>CRYPTOPP_FAST_ROTATE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRYPTOPP_FAST_ROTATE</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">0</div>
</div><!-- fragment -->
</div>
</div>
<a id="afb110e20bd83872104cf1b5a0d19ff1e" name="afb110e20bd83872104cf1b5a0d19ff1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb110e20bd83872104cf1b5a0d19ff1e">&#9670;&#160;</a></span>CRYPTOPP_GET_BYTE_AS_BYTE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRYPTOPP_GET_BYTE_AS_BYTE</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code hl_typedef" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>((x)&gt;&gt;(8*(y)))</div>
<div class="ttc" id="aconfig__int_8h_html_a0c8186d9b9b7880309c27230bbb5e69d"><div class="ttname"><a href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a></div><div class="ttdeci">unsigned char byte</div><div class="ttdoc">8-bit unsigned datatype</div><div class="ttdef"><b>Definition</b> config_int.h:66</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ad1938a2627b812913ac3d50c93fd5f11" name="ad1938a2627b812913ac3d50c93fd5f11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1938a2627b812913ac3d50c93fd5f11">&#9670;&#160;</a></span>EnumToInt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EnumToInt</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(v)</div>
</div><!-- fragment -->
<p><a class="el" href="class_integer.html" title="Multiple precision integer with arithmetic operations.">Integer</a> value. </p>
<p>EnumToInt avoids C++20 enum-enum conversion warnings under GCC and Clang. C++11 and above use a constexpr function. C++03 and below use a macro due to [lack of] constexpr-ness in early versions of C++. </p><dl class="section since"><dt>Since</dt><dd>Crypto++ 8.6 </dd></dl>

</div>
</div>
<a id="afb5d495902796a542084124233281265" name="afb5d495902796a542084124233281265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb5d495902796a542084124233281265">&#9670;&#160;</a></span>GETBYTE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GETBYTE</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(<span class="keywordtype">unsigned</span> int)<span class="keywordtype">byte</span>((x)&gt;&gt;(8*(y)))</div>
</div><!-- fragment -->
</div>
</div>
<a id="aff336cfe214604ffdd1075d94a11f8c5" name="aff336cfe214604ffdd1075d94a11f8c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff336cfe214604ffdd1075d94a11f8c5">&#9670;&#160;</a></span>RETURN_IF_NONZERO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RETURN_IF_NONZERO</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordtype">size_t</span> returnedValue = x; <span class="keywordflow">if</span> (returnedValue) <span class="keywordflow">return</span> returnedValue</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a3c5964768bc94670ad2bc3f218d9367f" name="a3c5964768bc94670ad2bc3f218d9367f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c5964768bc94670ad2bc3f218d9367f">&#9670;&#160;</a></span>BitPrecision()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int BitPrecision </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of bits required for a value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the maximum number of bits required to represent a value. </dd></dl>

</div>
</div>
<a id="a1746e70bf831f0cbf8ad73d8c15bc921" name="a1746e70bf831f0cbf8ad73d8c15bc921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1746e70bf831f0cbf8ad73d8c15bc921">&#9670;&#160;</a></span>BitReverse() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> BitReverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses bits in a 8-bit value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the 8-bit value to reverse</td></tr>
  </table>
  </dd>
</dl>
<p>BitReverse performs a combination of shifts on the byte. </p>

</div>
</div>
<a id="a641ecc1d620ac8c04bc43661a2bbba71" name="a641ecc1d620ac8c04bc43661a2bbba71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a641ecc1d620ac8c04bc43661a2bbba71">&#9670;&#160;</a></span>BitReverse() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T BitReverse </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses bits in a value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to reverse</td></tr>
  </table>
  </dd>
</dl>
<p>The template overload of BitReverse operates on signed and unsigned values. Internally the size of T is checked, and then value is cast to a byte, <a class="el" href="config__int_8h.html#ac32ea9831f54b53dfce00081c0d02681" title="16-bit unsigned datatype">word16</a>, <a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d" title="32-bit unsigned datatype">word32</a> or word64. After the cast, the appropriate BitReverse overload is called. </p><dl class="section note"><dt>Note</dt><dd>word128 is available on some 64-bit platforms when the compiler supports it. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 1.0, word128 since Crypto++ 8.7 </dd></dl>

</div>
</div>
<a id="a699c24d7013f20ee03076576984c875e" name="a699c24d7013f20ee03076576984c875e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a699c24d7013f20ee03076576984c875e">&#9670;&#160;</a></span>BitReverse() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config__int_8h.html#ac32ea9831f54b53dfce00081c0d02681">word16</a> BitReverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#ac32ea9831f54b53dfce00081c0d02681">word16</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses bits in a 16-bit value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the 16-bit value to reverse</td></tr>
  </table>
  </dd>
</dl>
<p>BitReverse performs a combination of shifts on the <a class="el" href="config__int_8h.html#ac32ea9831f54b53dfce00081c0d02681" title="16-bit unsigned datatype">word16</a>. </p>

</div>
</div>
<a id="aad87ebeafa7de2c11c19453f3b3cfea7" name="aad87ebeafa7de2c11c19453f3b3cfea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad87ebeafa7de2c11c19453f3b3cfea7">&#9670;&#160;</a></span>BitReverse() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a> BitReverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses bits in a 32-bit value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the 32-bit value to reverse</td></tr>
  </table>
  </dd>
</dl>
<p>BitReverse performs a combination of shifts on the <a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d" title="32-bit unsigned datatype">word32</a>. </p>

</div>
</div>
<a id="a336c0289dcd2670e6b4079fa98018d7a" name="a336c0289dcd2670e6b4079fa98018d7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a336c0289dcd2670e6b4079fa98018d7a">&#9670;&#160;</a></span>BitReverse() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">word64 BitReverse </td>
          <td>(</td>
          <td class="paramtype">word64</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses bits in a 64-bit value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the 64-bit value to reverse</td></tr>
  </table>
  </dd>
</dl>
<p>BitReverse performs a combination of shifts on the word64. </p>

</div>
</div>
<a id="a7c5d30b17c9d4869fdc3458dd05c500d" name="a7c5d30b17c9d4869fdc3458dd05c500d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c5d30b17c9d4869fdc3458dd05c500d">&#9670;&#160;</a></span>BitsToBytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t BitsToBytes </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>bitCount</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of 8-bit bytes or octets required for the specified number of bits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitCount</td><td>the number of bits </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the minimum number of 8-bit bytes or octets required by bitCount</dd></dl>
<p>BitsToBytes is effectively a ceiling function based on 8-bit bytes. </p>

</div>
</div>
<a id="a778d13f3d45915e1bc5c0ab1801ea6ad" name="a778d13f3d45915e1bc5c0ab1801ea6ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a778d13f3d45915e1bc5c0ab1801ea6ad">&#9670;&#160;</a></span>BitsToDwords()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t BitsToDwords </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>bitCount</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of double words required for the specified number of bits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitCount</td><td>the number of bits </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the minimum number of double words required by bitCount</dd></dl>
<p>BitsToDwords is effectively a ceiling function based on <code>2*WORD_BITS</code>. <code>WORD_BITS</code> is defined in config.h </p>

</div>
</div>
<a id="a45c56601a8c94b6a37a21657929fe928" name="a45c56601a8c94b6a37a21657929fe928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45c56601a8c94b6a37a21657929fe928">&#9670;&#160;</a></span>BitsToWords()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t BitsToWords </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>bitCount</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of words required for the specified number of bits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitCount</td><td>the number of bits </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the minimum number of words required by bitCount</dd></dl>
<p>BitsToWords is effectively a ceiling function based on <code>WORD_BITS</code>. <code>WORD_BITS</code> is defined in config.h </p>

</div>
</div>
<a id="a3e22fbd4b8f95aa01bde93ea32e44e82" name="a3e22fbd4b8f95aa01bde93ea32e44e82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e22fbd4b8f95aa01bde93ea32e44e82">&#9670;&#160;</a></span>BytePrecision()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int BytePrecision </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of 8-bit bytes or octets required for a value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the minimum number of 8-bit bytes or octets required to represent a value </dd></dl>

</div>
</div>
<a id="ae2d3a3222f6af55a6644b1f3e982b896" name="ae2d3a3222f6af55a6644b1f3e982b896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2d3a3222f6af55a6644b1f3e982b896">&#9670;&#160;</a></span>BytePtr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> * BytePtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sec_block.html">SecByteBlock</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to the first element of a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>SecByteBlock</td></tr>
  </table>
  </dd>
</dl>
<p>BytePtr returns NULL pointer for an empty string. </p><dl class="section return"><dt>Returns</dt><dd>Pointer to the first element of a string </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.3 </dd></dl>

</div>
</div>
<a id="ad6d8b623aebbbb1c4bfba1b8ba1ce25d" name="ad6d8b623aebbbb1c4bfba1b8ba1ce25d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6d8b623aebbbb1c4bfba1b8ba1ce25d">&#9670;&#160;</a></span>BytePtr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> * BytePtr </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer to the first element of a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string</td></tr>
  </table>
  </dd>
</dl>
<p>BytePtr returns NULL pointer for an empty string. </p><dl class="section return"><dt>Returns</dt><dd>Pointer to the first element of a string </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.0 </dd></dl>

</div>
</div>
<a id="a935acdd6640d177065caca6ddbab2ef2" name="a935acdd6640d177065caca6ddbab2ef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a935acdd6640d177065caca6ddbab2ef2">&#9670;&#160;</a></span>BytePtrSize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t BytePtrSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sec_block.html">SecByteBlock</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size of a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>SecByteBlock </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size of a string </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.3 </dd></dl>

</div>
</div>
<a id="a24eea25739f5000af6c684b8c225c6be" name="a24eea25739f5000af6c684b8c225c6be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24eea25739f5000af6c684b8c225c6be">&#9670;&#160;</a></span>BytePtrSize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t BytePtrSize </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Size of a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size of a string </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.3 </dd></dl>

</div>
</div>
<a id="a1d8d5adca8384ebedc699760ce217b08" name="a1d8d5adca8384ebedc699760ce217b08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d8d5adca8384ebedc699760ce217b08">&#9670;&#160;</a></span>ByteReverse() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> ByteReverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses bytes in a 8-bit value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the 8-bit value to reverse </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>ByteReverse returns the value passed to it since there is nothing to reverse. </dd></dl>

</div>
</div>
<a id="ab95e030e0abd33ea360d75cd9c4c8bbe" name="ab95e030e0abd33ea360d75cd9c4c8bbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab95e030e0abd33ea360d75cd9c4c8bbe">&#9670;&#160;</a></span>ByteReverse() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ByteReverse </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *</td>          <td class="paramname"><span class="paramname"><em>in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>byteCount</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverses bytes in an element from an array of elements. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output array of elements </td></tr>
    <tr><td class="paramname">in</td><td>the input array of elements </td></tr>
    <tr><td class="paramname">byteCount</td><td>the total number of bytes in the array</td></tr>
  </table>
  </dd>
</dl>
<p>Internally, ByteReverse visits each element in the in array calls ByteReverse on it, and writes the result to out.</p>
<p>ByteReverse does not process tail byes, or bytes that are not part of a full element. If T is int (and int is 4 bytes), then <code>byteCount = 10</code> means only the first 2 elements or 8 bytes are reversed.</p>
<p>The following program should help illustrate the behavior. </p><pre>vector&lt;word32&gt; v1, v2;

v1.push_back(1);
v1.push_back(2);
v1.push_back(3);
v1.push_back(4);

v2.resize(v1.size());
ByteReverse&lt;word32&gt;(&amp;v2[0], &amp;v1[0], 16);

cout &lt;&lt; "V1: ";
for(unsigned int i = 0; i &lt; v1.size(); i++)
  cout &lt;&lt; std::hex &lt;&lt; v1[i] &lt;&lt; " ";
cout &lt;&lt; endl;

cout &lt;&lt; "V2: ";
for(unsigned int i = 0; i &lt; v2.size(); i++)
  cout &lt;&lt; std::hex &lt;&lt; v2[i] &lt;&lt; " ";
cout &lt;&lt; endl;</pre><p> The program above results in the following output. </p><pre>V1: 00000001 00000002 00000003 00000004
V2: 01000000 02000000 03000000 04000000</pre> <dl class="section see"><dt>See also</dt><dd><a class="el" href="include_2cryptopp_2misc_8h.html#a8e499ded4f2e7e7705c3cfd39cdf137f" title="Reverses bytes in a value depending upon endianness.">ConditionalByteReverse</a> </dd></dl>

</div>
</div>
<a id="aa179e009cf5c74bb431b3c112d7ee444" name="aa179e009cf5c74bb431b3c112d7ee444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa179e009cf5c74bb431b3c112d7ee444">&#9670;&#160;</a></span>ByteReverse() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config__int_8h.html#ac32ea9831f54b53dfce00081c0d02681">word16</a> ByteReverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#ac32ea9831f54b53dfce00081c0d02681">word16</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses bytes in a 16-bit value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the 16-bit value to reverse</td></tr>
  </table>
  </dd>
</dl>
<p>ByteReverse calls bswap if available. Otherwise the function performs a 8-bit rotate on the <a class="el" href="config__int_8h.html#ac32ea9831f54b53dfce00081c0d02681" title="16-bit unsigned datatype">word16</a>. </p>

</div>
</div>
<a id="acf65f4a9edb6224d01e900aa7205a4f4" name="acf65f4a9edb6224d01e900aa7205a4f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf65f4a9edb6224d01e900aa7205a4f4">&#9670;&#160;</a></span>ByteReverse() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a> ByteReverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses bytes in a 32-bit value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the 32-bit value to reverse</td></tr>
  </table>
  </dd>
</dl>
<p>ByteReverse calls bswap if available. Otherwise the function uses a combination of rotates on the <a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d" title="32-bit unsigned datatype">word32</a>. </p>

</div>
</div>
<a id="a47686f3b4957541a58a3b280d1a89d4c" name="a47686f3b4957541a58a3b280d1a89d4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47686f3b4957541a58a3b280d1a89d4c">&#9670;&#160;</a></span>ByteReverse() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">word64 ByteReverse </td>
          <td>(</td>
          <td class="paramtype">word64</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses bytes in a 64-bit value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the 64-bit value to reverse</td></tr>
  </table>
  </dd>
</dl>
<p>ByteReverse calls bswap if available. Otherwise the function uses a combination of rotates on the word64. </p>

</div>
</div>
<a id="a886cc7ce76578c6df939f564f676e71a" name="a886cc7ce76578c6df939f564f676e71a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a886cc7ce76578c6df939f564f676e71a">&#9670;&#160;</a></span>BytesToWords()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t BytesToWords </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>byteCount</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of words required for the specified number of bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">byteCount</td><td>the number of bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the minimum number of words required by byteCount</dd></dl>
<p>BytesToWords is effectively a ceiling function based on <code>WORD_SIZE</code>. <code>WORD_SIZE</code> is defined in config.h </p>

</div>
</div>
<a id="aae0de65c1758668440f71a8ff6534ad9" name="aae0de65c1758668440f71a8ff6534ad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae0de65c1758668440f71a8ff6534ad9">&#9670;&#160;</a></span>ConditionalByteReverse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ConditionalByteReverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *</td>          <td class="paramname"><span class="paramname"><em>in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>byteCount</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conditionally reverses bytes in an element from an array of elements. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>the <a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b" title="Provides the byte ordering.">ByteOrder</a> of the data </td></tr>
    <tr><td class="paramname">out</td><td>the output array of elements </td></tr>
    <tr><td class="paramname">in</td><td>the input array of elements </td></tr>
    <tr><td class="paramname">byteCount</td><td>the byte count of the arrays</td></tr>
  </table>
  </dd>
</dl>
<p>ConditionalByteReverse visits each element in the in array calls ByteReverse on it depending on the desired endianness, and writes the result to out.</p>
<p>ByteReverse does not process tail byes, or bytes that are not part of a full element. If T is int (and int is 4 bytes), then <code>byteCount = 10</code> means only the first 2 elements or 8 bytes are reversed. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="include_2cryptopp_2misc_8h.html#a1d8d5adca8384ebedc699760ce217b08" title="Reverses bytes in a 8-bit value.">ByteReverse</a> </dd></dl>

</div>
</div>
<a id="a8e499ded4f2e7e7705c3cfd39cdf137f" name="a8e499ded4f2e7e7705c3cfd39cdf137f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e499ded4f2e7e7705c3cfd39cdf137f">&#9670;&#160;</a></span>ConditionalByteReverse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T ConditionalByteReverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses bytes in a value depending upon endianness. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>the <a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b" title="Provides the byte ordering.">ByteOrder</a> of the data </td></tr>
    <tr><td class="paramname">value</td><td>the value to conditionally reverse</td></tr>
  </table>
  </dd>
</dl>
<p>Internally, the ConditionalByteReverse calls NativeByteOrderIs. If order matches native byte order, then the original value is returned. If not, then ByteReverse is called on the value before returning to the caller. </p>

</div>
</div>
<a id="ae71e5659910553da22f9b1e877cddc07" name="ae71e5659910553da22f9b1e877cddc07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae71e5659910553da22f9b1e877cddc07">&#9670;&#160;</a></span>ConditionalSwap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ConditionalSwap </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a branch-less swap of values a and b if condition c is true. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the condition to perform the swap </td></tr>
    <tr><td class="paramname">a</td><td>the first value </td></tr>
    <tr><td class="paramname">b</td><td>the second value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a513e4522b268f9ee2e188606c2101d5a" name="a513e4522b268f9ee2e188606c2101d5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a513e4522b268f9ee2e188606c2101d5a">&#9670;&#160;</a></span>ConditionalSwapPointers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ConditionalSwapPointers </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a branch-less swap of pointers a and b if condition c is true. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the condition to perform the swap </td></tr>
    <tr><td class="paramname">a</td><td>the first pointer </td></tr>
    <tr><td class="paramname">b</td><td>the second pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a05cd70251b65c2de16dfbfc43bf26056" name="a05cd70251b65c2de16dfbfc43bf26056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05cd70251b65c2de16dfbfc43bf26056">&#9670;&#160;</a></span>ConstBytePtr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> * ConstBytePtr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sec_block.html">SecByteBlock</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const pointer to the first element of a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>SecByteBlock</td></tr>
  </table>
  </dd>
</dl>
<p>ConstBytePtr returns non-NULL pointer for an empty string. </p><dl class="section return"><dt>Returns</dt><dd>Pointer to the first element of a string </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.3 </dd></dl>

</div>
</div>
<a id="a7e44f8326c04036c4fbcde30cb5ab9e2" name="a7e44f8326c04036c4fbcde30cb5ab9e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e44f8326c04036c4fbcde30cb5ab9e2">&#9670;&#160;</a></span>ConstBytePtr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> * ConstBytePtr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const pointer to the first element of a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string</td></tr>
  </table>
  </dd>
</dl>
<p>ConstBytePtr returns non-NULL pointer for an empty string. </p><dl class="section return"><dt>Returns</dt><dd>Pointer to the first element of a string </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.0 </dd></dl>

</div>
</div>
<a id="a616a7f0365c4947b0c8a44606c525a62" name="a616a7f0365c4947b0c8a44606c525a62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a616a7f0365c4947b0c8a44606c525a62">&#9670;&#160;</a></span>Crop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Crop </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>bits</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Truncates the value to the specified number of bits. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to truncate or mask </td></tr>
    <tr><td class="paramname">bits</td><td>the number of bits to truncate or mask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value truncated to the specified number of bits, starting at the least significant bit position</dd></dl>
<p>This function masks the low-order bits of value and returns the result. The mask is created with <code>(1 &lt;&lt; bits) - 1</code>. </p>

</div>
</div>
<a id="ab29e4cf4553b1ff9f884df223a2abd6a" name="ab29e4cf4553b1ff9f884df223a2abd6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab29e4cf4553b1ff9f884df223a2abd6a">&#9670;&#160;</a></span>FindIfNot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt, typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">InputIt FindIfNot </td>
          <td>(</td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds first element not in a range. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIt</td><td>Input iterator type </td></tr>
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator to first element </td></tr>
    <tr><td class="paramname">last</td><td>iterator to last element </td></tr>
    <tr><td class="paramname">value</td><td>the value used as a predicate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the first element in the range that is not value </dd></dl>

</div>
</div>
<a id="ab4e438054095c88f0c4d9eda7efc584d" name="ab4e438054095c88f0c4d9eda7efc584d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4e438054095c88f0c4d9eda7efc584d">&#9670;&#160;</a></span>GetAlignmentOf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int GetAlignmentOf </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the minimum alignment requirements of a type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the minimum alignment requirements of <code>T</code>, in bytes</dd></dl>
<p>Internally the function calls C++11's <code>alignof</code> if available. If not available, then the function uses compiler specific extensions such as <code>__alignof</code> and <code><em>alignof</em></code>. If an extension is not available, then the function uses <code>sizeof(T)</code>. </p>

</div>
</div>
<a id="a9a2ceb73851e757cb436cdbaa0242219" name="a9a2ceb73851e757cb436cdbaa0242219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a2ceb73851e757cb436cdbaa0242219">&#9670;&#160;</a></span>GetByte()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int GetByte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a byte from a value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>the <a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b" title="Provides the byte ordering.">ByteOrder</a> of the value </td></tr>
    <tr><td class="paramname">value</td><td>the value to retrieve the byte </td></tr>
    <tr><td class="paramname">index</td><td>the location of the byte to retrieve </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ade22f7ed542b3db2912c917f8e3d6067" name="ade22f7ed542b3db2912c917f8e3d6067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade22f7ed542b3db2912c917f8e3d6067">&#9670;&#160;</a></span>GetCipherDir()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cryptlib_8h.html#a353ccabf5ddc119a6a33e92f7b9961c7">CipherDir</a> GetCipherDir </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>obj</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the direction the cipher is being operated. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>the cipher object being queried </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ENCRYPTION if the cipher obj is being operated in its forward direction, DECRYPTION otherwise</dd></dl>
<p>A cipher can be operated in a "forward" direction (encryption) or a "reverse" direction (decryption). The operations do not have to be symmetric, meaning a second application of the transformation does not necessarily return the original message. That is, <code>E(D(m))</code> may not equal <code>E(E(m))</code>; and <code>D(E(m))</code> may not equal <code>D(D(m))</code>. </p>

</div>
</div>
<a id="aed8336b0d98f2469441837be6cbbebf9" name="aed8336b0d98f2469441837be6cbbebf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed8336b0d98f2469441837be6cbbebf9">&#9670;&#160;</a></span>GetNativeByteOrder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> GetNativeByteOrder </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns NativeByteOrder as an enumerated <a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b" title="Provides the byte ordering.">ByteOrder</a> value. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="cryptlib_8h.html#ad00625e1e5e96656feaf83fd53c1ab4e" title="Provides a constant for LittleEndian.">LittleEndian</a> if the native byte order is little-endian, and <a class="el" href="cryptlib_8h.html#af2a408c806f842a5be8d06de7d6a1066" title="Provides a constant for BigEndian.">BigEndian</a> if the native byte order is big-endian</dd></dl>
<p>NativeByteOrder is a typedef depending on the platform. If CRYPTOPP_LITTLE_ENDIAN is set in config.h, then GetNativeByteOrder returns <a class="el" href="cryptlib_8h.html#ad00625e1e5e96656feaf83fd53c1ab4e" title="Provides a constant for LittleEndian.">LittleEndian</a>. If CRYPTOPP_BIG_ENDIAN is set, then GetNativeByteOrder returns <a class="el" href="cryptlib_8h.html#af2a408c806f842a5be8d06de7d6a1066" title="Provides a constant for BigEndian.">BigEndian</a>. </p><dl class="section note"><dt>Note</dt><dd>There are other byte orders besides little- and big-endian, and they include bi-endian and PDP-endian. If a system is neither little-endian nor big-endian, then a compile time error occurs. </dd></dl>

</div>
</div>
<a id="a929e347e6efedee4099dac8b3956350e" name="a929e347e6efedee4099dac8b3956350e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a929e347e6efedee4099dac8b3956350e">&#9670;&#160;</a></span>GetUserKey()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GetUserKey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>outlen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *</td>          <td class="paramname"><span class="paramname"><em>in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>inlen</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy bytes in a buffer to an array of elements in big-endian order. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>the <a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b" title="Provides the byte ordering.">ByteOrder</a> of the data </td></tr>
    <tr><td class="paramname">out</td><td>the output array of elements </td></tr>
    <tr><td class="paramname">outlen</td><td>the byte count of the array </td></tr>
    <tr><td class="paramname">in</td><td>the input array of elements </td></tr>
    <tr><td class="paramname">inlen</td><td>the byte count of the array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a240e8e97f964626508362b59b78532d3" name="a240e8e97f964626508362b59b78532d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a240e8e97f964626508362b59b78532d3">&#9670;&#160;</a></span>GetWord() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T GetWord </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>assumeAligned</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *</td>          <td class="paramname"><span class="paramname"><em>block</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access a block of memory. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">assumeAligned</td><td>flag indicating alignment </td></tr>
    <tr><td class="paramname">order</td><td>the <a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b" title="Provides the byte ordering.">ByteOrder</a> of the data </td></tr>
    <tr><td class="paramname">block</td><td>the byte buffer to be processed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the word in the specified byte order</dd></dl>
<p><a class="el" href="include_2cryptopp_2misc_8h.html#a240e8e97f964626508362b59b78532d3" title="Access a block of memory.">GetWord()</a> provides alternate read access to a block of memory. The flag assumeAligned indicates if the memory block is aligned for class or type T. The enumeration <a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b" title="Provides the byte ordering.">ByteOrder</a> is BIG_ENDIAN_ORDER or LITTLE_ENDIAN_ORDER.</p>
<p>An example of reading two <a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d" title="32-bit unsigned datatype">word32</a> values from a block of memory is shown below. <code>w</code> will be <code>0x03020100</code>. </p><pre>
  <a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d" title="32-bit unsigned datatype">word32</a> w;
  byte buffer[4] = {0,1,2,3};
  w = GetWord&lt;word32&gt;(false, LITTLE_ENDIAN_ORDER, buffer);
</pre> 
</div>
</div>
<a id="a4546cdeeecddedd3a0f784ea6b80c8bd" name="a4546cdeeecddedd3a0f784ea6b80c8bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4546cdeeecddedd3a0f784ea6b80c8bd">&#9670;&#160;</a></span>GetWord() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GetWord </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>assumeAligned</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>result</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *</td>          <td class="paramname"><span class="paramname"><em>block</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access a block of memory. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">assumeAligned</td><td>flag indicating alignment </td></tr>
    <tr><td class="paramname">order</td><td>the <a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b" title="Provides the byte ordering.">ByteOrder</a> of the data </td></tr>
    <tr><td class="paramname">result</td><td>the word in the specified byte order </td></tr>
    <tr><td class="paramname">block</td><td>the byte buffer to be processed</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="include_2cryptopp_2misc_8h.html#a240e8e97f964626508362b59b78532d3" title="Access a block of memory.">GetWord()</a> provides alternate read access to a block of memory. The flag assumeAligned indicates if the memory block is aligned for class or type T. The enumeration <a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b" title="Provides the byte ordering.">ByteOrder</a> is BIG_ENDIAN_ORDER or LITTLE_ENDIAN_ORDER.</p>
<p>An example of reading two <a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d" title="32-bit unsigned datatype">word32</a> values from a block of memory is shown below. <code>w</code> will be <code>0x03020100</code>. </p><pre>
  <a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d" title="32-bit unsigned datatype">word32</a> w;
  byte buffer[4] = {0,1,2,3};
  w = GetWord&lt;word32&gt;(false, LITTLE_ENDIAN_ORDER, buffer);
</pre> 
</div>
</div>
<a id="a44fad9d8c25e8aca3a7ee29345516f0a" name="a44fad9d8c25e8aca3a7ee29345516f0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44fad9d8c25e8aca3a7ee29345516f0a">&#9670;&#160;</a></span>IncrementCounterByOne() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IncrementCounterByOne </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *</td>          <td class="paramname"><span class="paramname"><em>inout</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs an addition with carry on a block of bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inout</td><td>the byte block </td></tr>
    <tr><td class="paramname">size</td><td>the size of the block, in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>Performs an addition with carry by adding 1 on a block of bytes starting at the least significant byte. Once carry is 0, the function terminates and returns to the caller. </p><dl class="section note"><dt>Note</dt><dd>The function is not constant time because it stops processing when the carry is 0. </dd></dl>

</div>
</div>
<a id="a2f852960b51e106a849781341cb2055c" name="a2f852960b51e106a849781341cb2055c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f852960b51e106a849781341cb2055c">&#9670;&#160;</a></span>IncrementCounterByOne() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IncrementCounterByOne </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *</td>          <td class="paramname"><span class="paramname"><em>output</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs an addition with carry on a block of bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>the destination block of bytes </td></tr>
    <tr><td class="paramname">input</td><td>the source block of bytes </td></tr>
    <tr><td class="paramname">size</td><td>the size of the block</td></tr>
  </table>
  </dd>
</dl>
<p>Performs an addition with carry on a block of bytes starting at the least significant byte. Once carry is 0, the remaining bytes from input are copied to output using memcpy.</p>
<p>The function is close to near-constant time because it operates on all the bytes in the blocks. </p>

</div>
</div>
<a id="a6cd7decd035cc4e144cd3d395e834106" name="a6cd7decd035cc4e144cd3d395e834106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cd7decd035cc4e144cd3d395e834106">&#9670;&#160;</a></span>IntToString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string IntToString </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>base</em></span><span class="paramdefsep"> = </span><span class="paramdefval">10</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a value to a string. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to convert </td></tr>
    <tr><td class="paramname">base</td><td>the base to use during the conversion </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the string representation of value in base. </dd></dl>

</div>
</div>
<a id="a1b67e971e2ab82125e3cf2a08a24a103" name="a1b67e971e2ab82125e3cf2a08a24a103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b67e971e2ab82125e3cf2a08a24a103">&#9670;&#160;</a></span>IntToString&lt; Integer &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CRYPTOPP_DLL std::string <a class="el" href="include_2cryptopp_2misc_8h.html#a6cd7decd035cc4e144cd3d395e834106">IntToString</a>&lt; <a class="el" href="class_integer.html">Integer</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_integer.html">Integer</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>base</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an <a class="el" href="class_integer.html" title="Multiple precision integer with arithmetic operations.">Integer</a> to a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the <a class="el" href="class_integer.html" title="Multiple precision integer with arithmetic operations.">Integer</a> to convert </td></tr>
    <tr><td class="paramname">base</td><td>the base to use during the conversion </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the string representation of value in base.</dd></dl>
<p>This is a template specialization of <a class="el" href="include_2cryptopp_2misc_8h.html#a6cd7decd035cc4e144cd3d395e834106" title="Converts a value to a string.">IntToString()</a>. Use it like <a class="el" href="include_2cryptopp_2misc_8h.html#a6cd7decd035cc4e144cd3d395e834106" title="Converts a value to a string.">IntToString()</a>: </p><pre>
 // Print integer in base 10
 <a class="el" href="class_integer.html" title="Multiple precision integer with arithmetic operations.">Integer</a> n...
 std::string s = IntToString(n, 10);
</pre><p>The string is presented with lowercase letters by default. A hack is available to switch to uppercase letters without modifying the function signature. </p><pre>
 // Print integer in base 16, uppercase letters
 <a class="el" href="class_integer.html" title="Multiple precision integer with arithmetic operations.">Integer</a> n...
 const unsigned int UPPER = (1 &lt;&lt; 31);
 std::string s = IntToString(n, (UPPER | 16));</pre> 
</div>
</div>
<a id="aad4f4608b867f01a4cad90c5b222f89b" name="aad4f4608b867f01a4cad90c5b222f89b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad4f4608b867f01a4cad90c5b222f89b">&#9670;&#160;</a></span>IntToString&lt; word64 &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CRYPTOPP_DLL std::string <a class="el" href="include_2cryptopp_2misc_8h.html#a6cd7decd035cc4e144cd3d395e834106">IntToString</a>&lt; word64 &gt; </td>
          <td>(</td>
          <td class="paramtype">word64</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>base</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an unsigned value to a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to convert </td></tr>
    <tr><td class="paramname">base</td><td>the base to use during the conversion </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the string representation of value in base.</dd></dl>
<p>this template function specialization was added to suppress Coverity findings on <a class="el" href="include_2cryptopp_2misc_8h.html#a6cd7decd035cc4e144cd3d395e834106" title="Converts a value to a string.">IntToString()</a> with unsigned types. </p>

</div>
</div>
<a id="a8b2c95659d16a971941622625c9102ae" name="a8b2c95659d16a971941622625c9102ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b2c95659d16a971941622625c9102ae">&#9670;&#160;</a></span>IsAligned()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IsAligned </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether ptr is minimally aligned. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>the pointer to check for alignment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <code>ptr</code> is aligned to at least <code>T</code> boundary, false otherwise</dd></dl>
<p>Internally the function calls IsAlignedOn with a second parameter of GetAlignmentOf&lt;T&gt;. </p>

</div>
</div>
<a id="a726c3b76265182681f5d5fd173ab5676" name="a726c3b76265182681f5d5fd173ab5676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a726c3b76265182681f5d5fd173ab5676">&#9670;&#160;</a></span>IsAlignedOn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IsAlignedOn </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>alignment</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether ptr is aligned to a minimum value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>the pointer being checked for alignment </td></tr>
    <tr><td class="paramname">alignment</td><td>the alignment value to test the pointer against </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <code>ptr</code> is aligned on at least <code>alignment</code> boundary, false otherwise</dd></dl>
<p>Internally the function tests whether alignment is 1. If so, the function returns true. If not, then the function effectively performs a modular reduction and returns true if the residue is 0. </p>

</div>
</div>
<a id="a65531618a7eca8803fa9e9287c43aafc" name="a65531618a7eca8803fa9e9287c43aafc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65531618a7eca8803fa9e9287c43aafc">&#9670;&#160;</a></span>IsPowerOf2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IsPowerOf2 </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether a value is a power of 2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if value is a power of 2, false otherwise</dd></dl>
<p>The function creates a mask of <code>value - 1</code> and returns the result of an AND operation compared to 0. If value is 0 or less than 0, then the function returns false. </p>

</div>
</div>
<a id="a5f6fcbaaf6f72fe46a6d911b033dfea0" name="a5f6fcbaaf6f72fe46a6d911b033dfea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f6fcbaaf6f72fe46a6d911b033dfea0">&#9670;&#160;</a></span>memcpy_s()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void memcpy_s </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>sizeInBytes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bounds checking replacement for memcpy() </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>pointer to the destination memory block </td></tr>
    <tr><td class="paramname">sizeInBytes</td><td>size of the destination memory block, in bytes </td></tr>
    <tr><td class="paramname">src</td><td>pointer to the source memory block </td></tr>
    <tr><td class="paramname">count</td><td>the number of bytes to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_invalid_argument.html" title="An invalid argument was detected.">InvalidArgument</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<p>ISO/IEC TR-24772 provides bounds checking interfaces for potentially unsafe functions like memcpy(), strcpy() and memmove(). However, not all standard libraries provides them, like Glibc. The library's <a class="el" href="include_2cryptopp_2misc_8h.html#a5f6fcbaaf6f72fe46a6d911b033dfea0" title="Bounds checking replacement for memcpy()">memcpy_s()</a> is a near-drop in replacement. Its only a near-replacement because the library's version throws an <a class="el" href="class_invalid_argument.html" title="An invalid argument was detected.">InvalidArgument</a> on a bounds violation.</p>
<p><a class="el" href="include_2cryptopp_2misc_8h.html#a5f6fcbaaf6f72fe46a6d911b033dfea0" title="Bounds checking replacement for memcpy()">memcpy_s()</a> and <a class="el" href="include_2cryptopp_2misc_8h.html#adb296eab4ca31ab5c0cf4a932488a8de" title="Bounds checking replacement for memmove()">memmove_s()</a> are guarded by <b>STDC_WANT_SECURE_LIB</b>. If <b>STDC_WANT_SECURE_LIB</b> is not defined or defined to 0, then the library makes <a class="el" href="include_2cryptopp_2misc_8h.html#a5f6fcbaaf6f72fe46a6d911b033dfea0" title="Bounds checking replacement for memcpy()">memcpy_s()</a> and <a class="el" href="include_2cryptopp_2misc_8h.html#adb296eab4ca31ab5c0cf4a932488a8de" title="Bounds checking replacement for memmove()">memmove_s()</a> available. The library will also optionally make the symbols available if <code>CRYPTOPP_WANT_SECURE_LIB</code> is defined. <code>CRYPTOPP_WANT_SECURE_LIB</code> is in config.h, but it is disabled by default.</p>
<p><a class="el" href="include_2cryptopp_2misc_8h.html#a5f6fcbaaf6f72fe46a6d911b033dfea0" title="Bounds checking replacement for memcpy()">memcpy_s()</a> will assert the pointers src and dest are not NULL in debug builds. Passing NULL for either pointer is undefined behavior. </p>

</div>
</div>
<a id="adb296eab4ca31ab5c0cf4a932488a8de" name="adb296eab4ca31ab5c0cf4a932488a8de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb296eab4ca31ab5c0cf4a932488a8de">&#9670;&#160;</a></span>memmove_s()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void memmove_s </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>sizeInBytes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bounds checking replacement for memmove() </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>pointer to the destination memory block </td></tr>
    <tr><td class="paramname">sizeInBytes</td><td>size of the destination memory block, in bytes </td></tr>
    <tr><td class="paramname">src</td><td>pointer to the source memory block </td></tr>
    <tr><td class="paramname">count</td><td>the number of bytes to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_invalid_argument.html" title="An invalid argument was detected.">InvalidArgument</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<p>ISO/IEC TR-24772 provides bounds checking interfaces for potentially unsafe functions like memcpy(), strcpy() and memmove(). However, not all standard libraries provides them, like Glibc. The library's <a class="el" href="include_2cryptopp_2misc_8h.html#adb296eab4ca31ab5c0cf4a932488a8de" title="Bounds checking replacement for memmove()">memmove_s()</a> is a near-drop in replacement. Its only a near-replacement because the library's version throws an <a class="el" href="class_invalid_argument.html" title="An invalid argument was detected.">InvalidArgument</a> on a bounds violation.</p>
<p><a class="el" href="include_2cryptopp_2misc_8h.html#a5f6fcbaaf6f72fe46a6d911b033dfea0" title="Bounds checking replacement for memcpy()">memcpy_s()</a> and <a class="el" href="include_2cryptopp_2misc_8h.html#adb296eab4ca31ab5c0cf4a932488a8de" title="Bounds checking replacement for memmove()">memmove_s()</a> are guarded by <b>STDC_WANT_SECURE_LIB</b>. If <b>STDC_WANT_SECURE_LIB</b> is not defined or defined to 0, then the library makes <a class="el" href="include_2cryptopp_2misc_8h.html#a5f6fcbaaf6f72fe46a6d911b033dfea0" title="Bounds checking replacement for memcpy()">memcpy_s()</a> and <a class="el" href="include_2cryptopp_2misc_8h.html#adb296eab4ca31ab5c0cf4a932488a8de" title="Bounds checking replacement for memmove()">memmove_s()</a> available. The library will also optionally make the symbols available if <code>CRYPTOPP_WANT_SECURE_LIB</code> is defined. <code>CRYPTOPP_WANT_SECURE_LIB</code> is in config.h, but it is disabled by default.</p>
<p><a class="el" href="include_2cryptopp_2misc_8h.html#adb296eab4ca31ab5c0cf4a932488a8de" title="Bounds checking replacement for memmove()">memmove_s()</a> will assert the pointers src and dest are not NULL in debug builds. Passing NULL for either pointer is undefined behavior. </p>

</div>
</div>
<a id="a356f99a6c1d7ae03f56a70ee1ecc1a22" name="a356f99a6c1d7ae03f56a70ee1ecc1a22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a356f99a6c1d7ae03f56a70ee1ecc1a22">&#9670;&#160;</a></span>memset_z()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * memset_z </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>num</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Memory block initializer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>pointer to the memory block being written </td></tr>
    <tr><td class="paramname">val</td><td>the integer value to write for each byte </td></tr>
    <tr><td class="paramname">num</td><td>the size of the source memory block, in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>Internally the function calls memset with the value <code>val</code>. memset_z can be used to initialize a freshly allocated memory block. To zeroize a memory block on destruction use <code>SecureWipeBuffer</code>. </p><dl class="section return"><dt>Returns</dt><dd>the pointer to the memory block </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="include_2cryptopp_2misc_8h.html#a656f38b8d0440981f5f013ada782018c" title="Sets each element of an array to 0.">SecureWipeBuffer</a> </dd></dl>

</div>
</div>
<a id="a621695f6346d6a745e340513d917b31a" name="a621695f6346d6a745e340513d917b31a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a621695f6346d6a745e340513d917b31a">&#9670;&#160;</a></span>ModPowerOf2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T2 ModPowerOf2 </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reduces a value to a power of 2. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>class or type </td></tr>
    <tr><td class="paramname">T2</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first value </td></tr>
    <tr><td class="paramname">b</td><td>the second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="include_2cryptopp_2misc_8h.html#a621695f6346d6a745e340513d917b31a" title="Reduces a value to a power of 2.">ModPowerOf2()</a> returns <code>a &amp; (b-1)</code>. <code>b</code> must be a power of 2. Use <a class="el" href="include_2cryptopp_2misc_8h.html#a65531618a7eca8803fa9e9287c43aafc" title="Tests whether a value is a power of 2.">IsPowerOf2()</a> to determine if <code>b</code> is a suitable candidate. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="include_2cryptopp_2misc_8h.html#a65531618a7eca8803fa9e9287c43aafc" title="Tests whether a value is a power of 2.">IsPowerOf2</a> </dd></dl>

</div>
</div>
<a id="a6c2da0dd866619761e63c3b5da58c477" name="a6c2da0dd866619761e63c3b5da58c477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c2da0dd866619761e63c3b5da58c477">&#9670;&#160;</a></span>NativeByteOrderIs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool NativeByteOrderIs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether order follows native byte ordering. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>the ordering being tested against native byte ordering </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if order follows native byte ordering, false otherwise </dd></dl>

</div>
</div>
<a id="af39f468338a6ad6a22fa0e9c16819fa7" name="af39f468338a6ad6a22fa0e9c16819fa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af39f468338a6ad6a22fa0e9c16819fa7">&#9670;&#160;</a></span>NumericLimitsMax()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T NumericLimitsMax </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide the maximum value for a type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of class </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the maximum value of the type or class</dd></dl>
<p><a class="el" href="include_2cryptopp_2misc_8h.html#af39f468338a6ad6a22fa0e9c16819fa7" title="Provide the maximum value for a type.">NumericLimitsMax()</a> was introduced for Clang at <a href="http://github.com/weidai11/cryptopp/issues/364">Issue 364, Apple Clang 6.0 and numeric_limits&lt;word128&gt;::max() returns 0</a>.</p>
<p><a class="el" href="include_2cryptopp_2misc_8h.html#af39f468338a6ad6a22fa0e9c16819fa7" title="Provide the maximum value for a type.">NumericLimitsMax()</a> requires a specialization for <code>T</code>, meaning <code>std::numeric_limits&lt;T&gt;::is_specialized</code> must return <code>true</code>. In the case of <code>word128</code> Clang did not specialize <code>numeric_limits</code> for the type. </p><dl class="section since"><dt>Since</dt><dd>Crypto++ 8.1 </dd></dl>

</div>
</div>
<a id="a67b8be26ba8900662fa86dcea6d831f9" name="a67b8be26ba8900662fa86dcea6d831f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67b8be26ba8900662fa86dcea6d831f9">&#9670;&#160;</a></span>NumericLimitsMin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T NumericLimitsMin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide the minimum value for a type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of class </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the minimum value of the type or class</dd></dl>
<p><a class="el" href="include_2cryptopp_2misc_8h.html#a67b8be26ba8900662fa86dcea6d831f9" title="Provide the minimum value for a type.">NumericLimitsMin()</a> was introduced for Clang at <a href="http://github.com/weidai11/cryptopp/issues/364">Issue 364, Apple Clang 6.0 and numeric_limits&lt;word128&gt;::max() returns 0</a>.</p>
<p><a class="el" href="include_2cryptopp_2misc_8h.html#a67b8be26ba8900662fa86dcea6d831f9" title="Provide the minimum value for a type.">NumericLimitsMin()</a> requires a specialization for <code>T</code>, meaning <code>std::numeric_limits&lt;T&gt;::is_specialized</code> must return <code>true</code>. In the case of <code>word128</code> Clang did not specialize <code>numeric_limits</code> for the type. </p><dl class="section since"><dt>Since</dt><dd>Crypto++ 8.1 </dd></dl>

</div>
</div>
<a id="a6c63a5683602db0ff8975746a414797f" name="a6c63a5683602db0ff8975746a414797f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c63a5683602db0ff8975746a414797f">&#9670;&#160;</a></span>Parity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Parity </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the parity of a value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to provide the parity </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the number 1-bits in the value is odd, 0 otherwise </dd></dl>

</div>
</div>
<a id="abe16d69257b3c86de97e8b0a9e851771" name="abe16d69257b3c86de97e8b0a9e851771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe16d69257b3c86de97e8b0a9e851771">&#9670;&#160;</a></span>PtrAdd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PTR, typename OFF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PTR PtrAdd </td>
          <td>(</td>
          <td class="paramtype">PTR</td>          <td class="paramname"><span class="paramname"><em>pointer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OFF</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a pointer with an offset. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PTR</td><td>a pointer type </td></tr>
    <tr><td class="paramname">OFF</td><td>a size type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pointer</td><td>a pointer </td></tr>
    <tr><td class="paramname">offset</td><td>a offset into the pointer</td></tr>
  </table>
  </dd>
</dl>
<p>PtrAdd can be used to squash Clang and GCC UBsan findings for pointer addition and subtraction. </p>

</div>
</div>
<a id="acacdab7254aa8a8bd6b56e2abb7b9083" name="acacdab7254aa8a8bd6b56e2abb7b9083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acacdab7254aa8a8bd6b56e2abb7b9083">&#9670;&#160;</a></span>PtrByteDiff()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PTR&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t PtrByteDiff </td>
          <td>(</td>
          <td class="paramtype">const PTR</td>          <td class="paramname"><span class="paramname"><em>pointer1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PTR</td>          <td class="paramname"><span class="paramname"><em>pointer2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine pointer difference. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PTR</td><td>a pointer type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pointer1</td><td>the first pointer </td></tr>
    <tr><td class="paramname">pointer2</td><td>the second pointer</td></tr>
  </table>
  </dd>
</dl>
<p>PtrByteDiff can be used to squash Clang and GCC UBsan findings for pointer addition and subtraction. pointer1 and pointer2 must point to the same object or array (or one past the end), and yields the number of bytes (not elements) difference. </p>

</div>
</div>
<a id="aa0afa8559681afcdbe5cd415cbde63e9" name="aa0afa8559681afcdbe5cd415cbde63e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0afa8559681afcdbe5cd415cbde63e9">&#9670;&#160;</a></span>PtrDiff()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PTR&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ptrdiff_t PtrDiff </td>
          <td>(</td>
          <td class="paramtype">const PTR</td>          <td class="paramname"><span class="paramname"><em>pointer1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PTR</td>          <td class="paramname"><span class="paramname"><em>pointer2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine pointer difference. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PTR</td><td>a pointer type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pointer1</td><td>the first pointer </td></tr>
    <tr><td class="paramname">pointer2</td><td>the second pointer</td></tr>
  </table>
  </dd>
</dl>
<p>PtrDiff can be used to squash Clang and GCC UBsan findings for pointer addition and subtraction. pointer1 and pointer2 must point to the same object or array (or one past the end), and yields the number of elements (not bytes) difference. </p>

</div>
</div>
<a id="a5e456f139d55e27318ba09d6a06d7960" name="a5e456f139d55e27318ba09d6a06d7960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e456f139d55e27318ba09d6a06d7960">&#9670;&#160;</a></span>PtrSub()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PTR, typename OFF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PTR PtrSub </td>
          <td>(</td>
          <td class="paramtype">PTR</td>          <td class="paramname"><span class="paramname"><em>pointer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OFF</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a pointer with an offset. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PTR</td><td>a pointer type </td></tr>
    <tr><td class="paramname">OFF</td><td>a size type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pointer</td><td>a pointer </td></tr>
    <tr><td class="paramname">offset</td><td>a offset into the pointer</td></tr>
  </table>
  </dd>
</dl>
<p>PtrSub can be used to squash Clang and GCC UBsan findings for pointer addition and subtraction. </p>

</div>
</div>
<a id="a096e90ab9bb746edf908d25f0856a786" name="a096e90ab9bb746edf908d25f0856a786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a096e90ab9bb746edf908d25f0856a786">&#9670;&#160;</a></span>PutWord()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PutWord </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>assumeAligned</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *</td>          <td class="paramname"><span class="paramname"><em>block</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *</td>          <td class="paramname"><span class="paramname"><em>xorBlock</em></span><span class="paramdefsep"> = </span><span class="paramdefval">NULLPTR</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access a block of memory. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">assumeAligned</td><td>flag indicating alignment </td></tr>
    <tr><td class="paramname">order</td><td>the <a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b" title="Provides the byte ordering.">ByteOrder</a> of the data </td></tr>
    <tr><td class="paramname">block</td><td>the destination byte buffer </td></tr>
    <tr><td class="paramname">value</td><td>the word in the specified byte order </td></tr>
    <tr><td class="paramname">xorBlock</td><td>an optional byte buffer to xor</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="include_2cryptopp_2misc_8h.html#a096e90ab9bb746edf908d25f0856a786" title="Access a block of memory.">PutWord()</a> provides alternate write access to a block of memory. The flag assumeAligned indicates if the memory block is aligned for class or type T. The enumeration <a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b" title="Provides the byte ordering.">ByteOrder</a> is BIG_ENDIAN_ORDER or LITTLE_ENDIAN_ORDER. </p>

</div>
</div>
<a id="a0ab6928faa40f6e56e7f4817d5d65a38" name="a0ab6928faa40f6e56e7f4817d5d65a38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ab6928faa40f6e56e7f4817d5d65a38">&#9670;&#160;</a></span>rotlConstant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int R, class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T rotlConstant </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a left rotate. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>the number of bit positions to rotate the value </td></tr>
    <tr><td class="paramname">T</td><td>the word type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the value to rotate</td></tr>
  </table>
  </dd>
</dl>
<p>This is a portable C/C++ implementation. The value x to be rotated can be 8 to 64-bits wide.</p>
<p>R must be in the range <code>[0, sizeof(T)*8 - 1]</code> to avoid undefined behavior. Use rotlMod if the rotate amount R is outside the range.</p>
<p>Use rotlConstant when the rotate amount is constant. The template function was added because Clang did not propagate the constant when passed as a function parameter. Clang's need for a constexpr meant rotlFixed failed to compile on occasion. </p><dl class="section note"><dt>Note</dt><dd>rotlConstant attempts to enlist a <code>rotate IMM</code> instruction because its often faster than a <code>rotate REG</code>. Immediate rotates can be up to three times faster than their register counterparts. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="include_2cryptopp_2misc_8h.html#a0ab6928faa40f6e56e7f4817d5d65a38" title="Performs a left rotate.">rotlConstant</a>, <a class="el" href="include_2cryptopp_2misc_8h.html#a7d777068849add4c7ab87f7b0683ef65" title="Performs a right rotate.">rotrConstant</a>, <a class="el" href="include_2cryptopp_2misc_8h.html#aaf7b80a08d25ab9d62693c9e4798ef98" title="Performs a left rotate.">rotlFixed</a>, <a class="el" href="include_2cryptopp_2misc_8h.html#abf88e95400925b89c94641916535b6da" title="Performs a right rotate.">rotrFixed</a>, <a class="el" href="include_2cryptopp_2misc_8h.html#a0de05253683b27a221e6465b3a7453b2" title="Performs a left rotate.">rotlVariable</a>, <a class="el" href="include_2cryptopp_2misc_8h.html#abd053d245fe902fe55bfd8a335634110" title="Performs a right rotate.">rotrVariable</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 6.0 </dd></dl>

</div>
</div>
<a id="aaf7b80a08d25ab9d62693c9e4798ef98" name="aaf7b80a08d25ab9d62693c9e4798ef98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf7b80a08d25ab9d62693c9e4798ef98">&#9670;&#160;</a></span>rotlFixed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T rotlFixed </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a left rotate. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the word type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the value to rotate </td></tr>
    <tr><td class="paramname">y</td><td>the number of bit positions to rotate the value</td></tr>
  </table>
  </dd>
</dl>
<p>This is a portable C/C++ implementation. The value x to be rotated can be 8 to 64-bits wide.</p>
<p>y must be in the range <code>[0, sizeof(T)*8 - 1]</code> to avoid undefined behavior. Use rotlMod if the rotate amount y is outside the range. </p><dl class="section note"><dt>Note</dt><dd>rotlFixed attempts to enlist a <code>rotate IMM</code> instruction because its often faster than a <code>rotate REG</code>. Immediate rotates can be up to three times faster than their register counterparts. New code should use <code>rotlConstant</code>, which accepts the rotate amount as a template parameter. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="include_2cryptopp_2misc_8h.html#a0ab6928faa40f6e56e7f4817d5d65a38" title="Performs a left rotate.">rotlConstant</a>, <a class="el" href="include_2cryptopp_2misc_8h.html#a7d777068849add4c7ab87f7b0683ef65" title="Performs a right rotate.">rotrConstant</a>, <a class="el" href="include_2cryptopp_2misc_8h.html#aaf7b80a08d25ab9d62693c9e4798ef98" title="Performs a left rotate.">rotlFixed</a>, <a class="el" href="include_2cryptopp_2misc_8h.html#abf88e95400925b89c94641916535b6da" title="Performs a right rotate.">rotrFixed</a>, <a class="el" href="include_2cryptopp_2misc_8h.html#a0de05253683b27a221e6465b3a7453b2" title="Performs a left rotate.">rotlVariable</a>, <a class="el" href="include_2cryptopp_2misc_8h.html#abd053d245fe902fe55bfd8a335634110" title="Performs a right rotate.">rotrVariable</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 6.0 </dd></dl>

</div>
</div>
<a id="ad31fe5d559d014085c6a49594b817196" name="ad31fe5d559d014085c6a49594b817196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad31fe5d559d014085c6a49594b817196">&#9670;&#160;</a></span>rotlMod()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T rotlMod </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a left rotate. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the word type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the value to rotate </td></tr>
    <tr><td class="paramname">y</td><td>the number of bit positions to rotate the value</td></tr>
  </table>
  </dd>
</dl>
<p>This is a portable C/C++ implementation. The value x to be rotated can be 8 to 64-bits wide.</p>
<p>y is reduced to the range <code>[0, sizeof(T)*8 - 1]</code> to avoid undefined behavior. </p><dl class="section note"><dt>Note</dt><dd>rotrVariable will use either <code>rotate IMM</code> or <code>rotate REG</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="include_2cryptopp_2misc_8h.html#a0ab6928faa40f6e56e7f4817d5d65a38" title="Performs a left rotate.">rotlConstant</a>, <a class="el" href="include_2cryptopp_2misc_8h.html#a7d777068849add4c7ab87f7b0683ef65" title="Performs a right rotate.">rotrConstant</a>, <a class="el" href="include_2cryptopp_2misc_8h.html#aaf7b80a08d25ab9d62693c9e4798ef98" title="Performs a left rotate.">rotlFixed</a>, <a class="el" href="include_2cryptopp_2misc_8h.html#abf88e95400925b89c94641916535b6da" title="Performs a right rotate.">rotrFixed</a>, <a class="el" href="include_2cryptopp_2misc_8h.html#a0de05253683b27a221e6465b3a7453b2" title="Performs a left rotate.">rotlVariable</a>, <a class="el" href="include_2cryptopp_2misc_8h.html#abd053d245fe902fe55bfd8a335634110" title="Performs a right rotate.">rotrVariable</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 3.0 </dd></dl>

</div>
</div>
<a id="a0de05253683b27a221e6465b3a7453b2" name="a0de05253683b27a221e6465b3a7453b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0de05253683b27a221e6465b3a7453b2">&#9670;&#160;</a></span>rotlVariable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T rotlVariable </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a left rotate. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the word type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the value to rotate </td></tr>
    <tr><td class="paramname">y</td><td>the number of bit positions to rotate the value</td></tr>
  </table>
  </dd>
</dl>
<p>This is a portable C/C++ implementation. The value x to be rotated can be 8 to 64-bits wide.</p>
<p>y must be in the range <code>[0, sizeof(T)*8 - 1]</code> to avoid undefined behavior. Use rotlMod if the rotate amount y is outside the range. </p><dl class="section note"><dt>Note</dt><dd>rotlVariable attempts to enlist a <code>rotate IMM</code> instruction because its often faster than a <code>rotate REG</code>. Immediate rotates can be up to three times faster than their register counterparts. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="include_2cryptopp_2misc_8h.html#a0ab6928faa40f6e56e7f4817d5d65a38" title="Performs a left rotate.">rotlConstant</a>, <a class="el" href="include_2cryptopp_2misc_8h.html#a7d777068849add4c7ab87f7b0683ef65" title="Performs a right rotate.">rotrConstant</a>, <a class="el" href="include_2cryptopp_2misc_8h.html#aaf7b80a08d25ab9d62693c9e4798ef98" title="Performs a left rotate.">rotlFixed</a>, <a class="el" href="include_2cryptopp_2misc_8h.html#abf88e95400925b89c94641916535b6da" title="Performs a right rotate.">rotrFixed</a>, <a class="el" href="include_2cryptopp_2misc_8h.html#a0de05253683b27a221e6465b3a7453b2" title="Performs a left rotate.">rotlVariable</a>, <a class="el" href="include_2cryptopp_2misc_8h.html#abd053d245fe902fe55bfd8a335634110" title="Performs a right rotate.">rotrVariable</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 3.0 </dd></dl>

</div>
</div>
<a id="a7d777068849add4c7ab87f7b0683ef65" name="a7d777068849add4c7ab87f7b0683ef65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d777068849add4c7ab87f7b0683ef65">&#9670;&#160;</a></span>rotrConstant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int R, class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T rotrConstant </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a right rotate. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>the number of bit positions to rotate the value </td></tr>
    <tr><td class="paramname">T</td><td>the word type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the value to rotate</td></tr>
  </table>
  </dd>
</dl>
<p>This is a portable C/C++ implementation. The value x to be rotated can be 8 to 64-bits wide.</p>
<p>R must be in the range <code>[0, sizeof(T)*8 - 1]</code> to avoid undefined behavior. Use rotrMod if the rotate amount R is outside the range.</p>
<p>Use rotrConstant when the rotate amount is constant. The template function was added because Clang did not propagate the constant when passed as a function parameter. Clang's need for a constexpr meant rotrFixed failed to compile on occasion. </p><dl class="section note"><dt>Note</dt><dd>rotrConstant attempts to enlist a <code>rotate IMM</code> instruction because its often faster than a <code>rotate REG</code>. Immediate rotates can be up to three times faster than their register counterparts. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="include_2cryptopp_2misc_8h.html#a0ab6928faa40f6e56e7f4817d5d65a38" title="Performs a left rotate.">rotlConstant</a>, <a class="el" href="include_2cryptopp_2misc_8h.html#a7d777068849add4c7ab87f7b0683ef65" title="Performs a right rotate.">rotrConstant</a>, <a class="el" href="include_2cryptopp_2misc_8h.html#aaf7b80a08d25ab9d62693c9e4798ef98" title="Performs a left rotate.">rotlFixed</a>, <a class="el" href="include_2cryptopp_2misc_8h.html#abf88e95400925b89c94641916535b6da" title="Performs a right rotate.">rotrFixed</a>, <a class="el" href="include_2cryptopp_2misc_8h.html#a0de05253683b27a221e6465b3a7453b2" title="Performs a left rotate.">rotlVariable</a>, <a class="el" href="include_2cryptopp_2misc_8h.html#abd053d245fe902fe55bfd8a335634110" title="Performs a right rotate.">rotrVariable</a> </dd></dl>

</div>
</div>
<a id="abf88e95400925b89c94641916535b6da" name="abf88e95400925b89c94641916535b6da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf88e95400925b89c94641916535b6da">&#9670;&#160;</a></span>rotrFixed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T rotrFixed </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a right rotate. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the word type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the value to rotate </td></tr>
    <tr><td class="paramname">y</td><td>the number of bit positions to rotate the value</td></tr>
  </table>
  </dd>
</dl>
<p>This is a portable C/C++ implementation. The value x to be rotated can be 8 to 64-bits wide.</p>
<p>y must be in the range <code>[0, sizeof(T)*8 - 1]</code> to avoid undefined behavior. Use rotrMod if the rotate amount y is outside the range. </p><dl class="section note"><dt>Note</dt><dd>rotrFixed attempts to enlist a <code>rotate IMM</code> instruction because its often faster than a <code>rotate REG</code>. Immediate rotates can be up to three times faster than their register counterparts. New code should use <code>rotrConstant</code>, which accepts the rotate amount as a template parameter. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="include_2cryptopp_2misc_8h.html#a0ab6928faa40f6e56e7f4817d5d65a38" title="Performs a left rotate.">rotlConstant</a>, <a class="el" href="include_2cryptopp_2misc_8h.html#a7d777068849add4c7ab87f7b0683ef65" title="Performs a right rotate.">rotrConstant</a>, <a class="el" href="include_2cryptopp_2misc_8h.html#aaf7b80a08d25ab9d62693c9e4798ef98" title="Performs a left rotate.">rotlFixed</a>, <a class="el" href="include_2cryptopp_2misc_8h.html#abf88e95400925b89c94641916535b6da" title="Performs a right rotate.">rotrFixed</a>, <a class="el" href="include_2cryptopp_2misc_8h.html#a0de05253683b27a221e6465b3a7453b2" title="Performs a left rotate.">rotlVariable</a>, <a class="el" href="include_2cryptopp_2misc_8h.html#abd053d245fe902fe55bfd8a335634110" title="Performs a right rotate.">rotrVariable</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 3.0 </dd></dl>

</div>
</div>
<a id="ae8fc34eb834dd2424407d5e4d729594e" name="ae8fc34eb834dd2424407d5e4d729594e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8fc34eb834dd2424407d5e4d729594e">&#9670;&#160;</a></span>rotrMod()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T rotrMod </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a right rotate. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the word type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the value to rotate </td></tr>
    <tr><td class="paramname">y</td><td>the number of bit positions to rotate the value</td></tr>
  </table>
  </dd>
</dl>
<p>This is a portable C/C++ implementation. The value x to be rotated can be 8 to 64-bits wide.</p>
<p>y is reduced to the range <code>[0, sizeof(T)*8 - 1]</code> to avoid undefined behavior. </p><dl class="section note"><dt>Note</dt><dd>rotrVariable will use either <code>rotate IMM</code> or <code>rotate REG</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="include_2cryptopp_2misc_8h.html#a0ab6928faa40f6e56e7f4817d5d65a38" title="Performs a left rotate.">rotlConstant</a>, <a class="el" href="include_2cryptopp_2misc_8h.html#a7d777068849add4c7ab87f7b0683ef65" title="Performs a right rotate.">rotrConstant</a>, <a class="el" href="include_2cryptopp_2misc_8h.html#aaf7b80a08d25ab9d62693c9e4798ef98" title="Performs a left rotate.">rotlFixed</a>, <a class="el" href="include_2cryptopp_2misc_8h.html#abf88e95400925b89c94641916535b6da" title="Performs a right rotate.">rotrFixed</a>, <a class="el" href="include_2cryptopp_2misc_8h.html#a0de05253683b27a221e6465b3a7453b2" title="Performs a left rotate.">rotlVariable</a>, <a class="el" href="include_2cryptopp_2misc_8h.html#abd053d245fe902fe55bfd8a335634110" title="Performs a right rotate.">rotrVariable</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 3.0 </dd></dl>

</div>
</div>
<a id="abd053d245fe902fe55bfd8a335634110" name="abd053d245fe902fe55bfd8a335634110"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd053d245fe902fe55bfd8a335634110">&#9670;&#160;</a></span>rotrVariable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T rotrVariable </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a right rotate. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the word type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the value to rotate </td></tr>
    <tr><td class="paramname">y</td><td>the number of bit positions to rotate the value</td></tr>
  </table>
  </dd>
</dl>
<p>This is a portable C/C++ implementation. The value x to be rotated can be 8 to 64-bits wide.</p>
<p>y must be in the range <code>[0, sizeof(T)*8 - 1]</code> to avoid undefined behavior. Use rotrMod if the rotate amount y is outside the range. </p><dl class="section note"><dt>Note</dt><dd>rotrVariable attempts to enlist a <code>rotate IMM</code> instruction because its often faster than a <code>rotate REG</code>. Immediate rotates can be up to three times faster than their register counterparts. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="include_2cryptopp_2misc_8h.html#a0ab6928faa40f6e56e7f4817d5d65a38" title="Performs a left rotate.">rotlConstant</a>, <a class="el" href="include_2cryptopp_2misc_8h.html#a7d777068849add4c7ab87f7b0683ef65" title="Performs a right rotate.">rotrConstant</a>, <a class="el" href="include_2cryptopp_2misc_8h.html#aaf7b80a08d25ab9d62693c9e4798ef98" title="Performs a left rotate.">rotlFixed</a>, <a class="el" href="include_2cryptopp_2misc_8h.html#abf88e95400925b89c94641916535b6da" title="Performs a right rotate.">rotrFixed</a>, <a class="el" href="include_2cryptopp_2misc_8h.html#a0de05253683b27a221e6465b3a7453b2" title="Performs a left rotate.">rotlVariable</a>, <a class="el" href="include_2cryptopp_2misc_8h.html#abd053d245fe902fe55bfd8a335634110" title="Performs a right rotate.">rotrVariable</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 3.0 </dd></dl>

</div>
</div>
<a id="aa2ac57210cb6796eced074e6d2e294fb" name="aa2ac57210cb6796eced074e6d2e294fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2ac57210cb6796eced074e6d2e294fb">&#9670;&#160;</a></span>RoundDownToMultipleOf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T1 RoundDownToMultipleOf </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds a value down to a multiple of a second value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>class or type </td></tr>
    <tr><td class="paramname">T2</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the value to reduce </td></tr>
    <tr><td class="paramname">m</td><td>the value to reduce <code>n</code> to a multiple </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the possibly unmodified value <br  />
</dd></dl>
<p>RoundDownToMultipleOf is effectively a floor function based on m. The function returns the value <code>n - n%m</code>. If n is a multiple of m, then the original value is returned. </p><dl class="section note"><dt>Note</dt><dd><code>T1</code> and <code>T2</code> should be unsigned arithmetic types. If <code>T1</code> or <code>T2</code> is signed, then the value should be non-negative. The library asserts in debug builds when practical, but allows you to perform the operation in release builds. </dd></dl>

</div>
</div>
<a id="a57a219d44f45272a1f3b3f17a656000a" name="a57a219d44f45272a1f3b3f17a656000a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57a219d44f45272a1f3b3f17a656000a">&#9670;&#160;</a></span>RoundUpToMultipleOf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T1 RoundUpToMultipleOf </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds a value up to a multiple of a second value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>class or type </td></tr>
    <tr><td class="paramname">T2</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the value to reduce </td></tr>
    <tr><td class="paramname">m</td><td>the value to reduce <code>n</code> to a multiple </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the possibly unmodified value <br  />
</dd></dl>
<p>RoundUpToMultipleOf is effectively a ceiling function based on m. The function returns the value <code>n + n%m</code>. If n is a multiple of m, then the original value is returned. If the value n would overflow, then an <a class="el" href="class_invalid_argument.html" title="An invalid argument was detected.">InvalidArgument</a> exception is thrown. </p><dl class="section note"><dt>Note</dt><dd><code>T1</code> and <code>T2</code> should be unsigned arithmetic types. If <code>T1</code> or <code>T2</code> is signed, then the value should be non-negative. The library asserts in debug builds when practical, but allows you to perform the operation in release builds. </dd></dl>

</div>
</div>
<a id="ad0a9752786a04193c6219f18b02050bb" name="ad0a9752786a04193c6219f18b02050bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0a9752786a04193c6219f18b02050bb">&#9670;&#160;</a></span>SafeConvert() <span class="overload">[1/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SafeConvert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a3304866b527056436d1a444813cd5f6d">sword32</a></td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sword64 &amp;</td>          <td class="paramname"><span class="paramname"><em>to</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a conversion from <code class="param">from</code> to <code class="param">to</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>the first value </td></tr>
    <tr><td class="paramname">to</td><td>the second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if its safe to convert from <code class="param">from</code> to <code class="param">to</code>, false otherwise.</dd></dl>
<p>if the function returns true, then it is safe to use <code class="param">to</code>. If the function returns false, then <code class="param">to</code> is undefined and should not be used. </p><dl class="section since"><dt>Since</dt><dd>Crypto++ 8.8 </dd></dl>

</div>
</div>
<a id="a051380375fe085115451a06b84d68c3d" name="a051380375fe085115451a06b84d68c3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a051380375fe085115451a06b84d68c3d">&#9670;&#160;</a></span>SafeConvert() <span class="overload">[2/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SafeConvert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a3304866b527056436d1a444813cd5f6d">sword32</a></td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>to</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a conversion from <code class="param">from</code> to <code class="param">to</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>the first value </td></tr>
    <tr><td class="paramname">to</td><td>the second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if its safe to convert from <code class="param">from</code> to <code class="param">to</code>, false otherwise.</dd></dl>
<p>if the function returns true, then it is safe to use <code class="param">to</code>. If the function returns false, then <code class="param">to</code> is undefined and should not be used. </p><dl class="section since"><dt>Since</dt><dd>Crypto++ 8.8 </dd></dl>

</div>
</div>
<a id="a0052b1609559f5e113905d54d429711a" name="a0052b1609559f5e113905d54d429711a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0052b1609559f5e113905d54d429711a">&#9670;&#160;</a></span>SafeConvert() <span class="overload">[3/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SafeConvert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a3304866b527056436d1a444813cd5f6d">sword32</a></td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word64 &amp;</td>          <td class="paramname"><span class="paramname"><em>to</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a conversion from <code class="param">from</code> to <code class="param">to</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>the first value </td></tr>
    <tr><td class="paramname">to</td><td>the second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if its safe to convert from <code class="param">from</code> to <code class="param">to</code>, false otherwise.</dd></dl>
<p>if the function returns true, then it is safe to use <code class="param">to</code>. If the function returns false, then <code class="param">to</code> is undefined and should not be used. </p><dl class="section since"><dt>Since</dt><dd>Crypto++ 8.8 </dd></dl>

</div>
</div>
<a id="a66c8abb585a36d6117ce1c29c54aeab2" name="a66c8abb585a36d6117ce1c29c54aeab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66c8abb585a36d6117ce1c29c54aeab2">&#9670;&#160;</a></span>SafeConvert() <span class="overload">[4/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SafeConvert </td>
          <td>(</td>
          <td class="paramtype">sword64</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a3304866b527056436d1a444813cd5f6d">sword32</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>to</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a conversion from <code class="param">from</code> to <code class="param">to</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>the first value </td></tr>
    <tr><td class="paramname">to</td><td>the second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if its safe to convert from <code class="param">from</code> to <code class="param">to</code>, false otherwise.</dd></dl>
<p>if the function returns true, then it is safe to use <code class="param">to</code>. If the function returns false, then <code class="param">to</code> is undefined and should not be used. </p><dl class="section since"><dt>Since</dt><dd>Crypto++ 8.8 </dd></dl>

</div>
</div>
<a id="a9dbe71bd3d318f5b7be175b3f2997208" name="a9dbe71bd3d318f5b7be175b3f2997208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dbe71bd3d318f5b7be175b3f2997208">&#9670;&#160;</a></span>SafeConvert() <span class="overload">[5/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SafeConvert </td>
          <td>(</td>
          <td class="paramtype">sword64</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>to</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a conversion from <code class="param">from</code> to <code class="param">to</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>the first value </td></tr>
    <tr><td class="paramname">to</td><td>the second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if its safe to convert from <code class="param">from</code> to <code class="param">to</code>, false otherwise.</dd></dl>
<p>if the function returns true, then it is safe to use <code class="param">to</code>. If the function returns false, then <code class="param">to</code> is undefined and should not be used. </p><dl class="section since"><dt>Since</dt><dd>Crypto++ 8.8 </dd></dl>

</div>
</div>
<a id="aef9c6fb182e29b6f83218f0277b814ce" name="aef9c6fb182e29b6f83218f0277b814ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef9c6fb182e29b6f83218f0277b814ce">&#9670;&#160;</a></span>SafeConvert() <span class="overload">[6/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SafeConvert </td>
          <td>(</td>
          <td class="paramtype">sword64</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word64 &amp;</td>          <td class="paramname"><span class="paramname"><em>to</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a conversion from <code class="param">from</code> to <code class="param">to</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>the first value </td></tr>
    <tr><td class="paramname">to</td><td>the second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if its safe to convert from <code class="param">from</code> to <code class="param">to</code>, false otherwise.</dd></dl>
<p>if the function returns true, then it is safe to use <code class="param">to</code>. If the function returns false, then <code class="param">to</code> is undefined and should not be used. </p><dl class="section since"><dt>Since</dt><dd>Crypto++ 8.8 </dd></dl>

</div>
</div>
<a id="a8a2ce94589bb74164d809f4675bd23dd" name="a8a2ce94589bb74164d809f4675bd23dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a2ce94589bb74164d809f4675bd23dd">&#9670;&#160;</a></span>SafeConvert() <span class="overload">[7/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SafeConvert </td>
          <td>(</td>
          <td class="paramtype">T1</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 &amp;</td>          <td class="paramname"><span class="paramname"><em>to</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a conversion from <code class="param">from</code> to <code class="param">to</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>class or type </td></tr>
    <tr><td class="paramname">T2</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>the first value </td></tr>
    <tr><td class="paramname">to</td><td>the second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if its safe to convert from <code class="param">from</code> to <code class="param">to</code>, false otherwise.</dd></dl>
<p>if the function returns true, then it is safe to use <code class="param">to</code>. If the function returns false, then <code class="param">to</code> is undefined and should not be used. </p><dl class="section note"><dt>Note</dt><dd>for integral conversions, a template specialization should be provided. The specialization will perform more efficiently, and avoid warnings for truncation and sign compares. </dd></dl>

</div>
</div>
<a id="a45edf61e9d5dae4e1062d29d9059297b" name="a45edf61e9d5dae4e1062d29d9059297b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45edf61e9d5dae4e1062d29d9059297b">&#9670;&#160;</a></span>SafeConvert() <span class="overload">[8/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SafeConvert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a></td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a3304866b527056436d1a444813cd5f6d">sword32</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>to</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a conversion from <code class="param">from</code> to <code class="param">to</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>the first value </td></tr>
    <tr><td class="paramname">to</td><td>the second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if its safe to convert from <code class="param">from</code> to <code class="param">to</code>, false otherwise.</dd></dl>
<p>if the function returns true, then it is safe to use <code class="param">to</code>. If the function returns false, then <code class="param">to</code> is undefined and should not be used. </p><dl class="section since"><dt>Since</dt><dd>Crypto++ 8.8 </dd></dl>

</div>
</div>
<a id="a3d868daec4a6485ea8393ed87202db2e" name="a3d868daec4a6485ea8393ed87202db2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d868daec4a6485ea8393ed87202db2e">&#9670;&#160;</a></span>SafeConvert() <span class="overload">[9/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SafeConvert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a></td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sword64 &amp;</td>          <td class="paramname"><span class="paramname"><em>to</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a conversion from <code class="param">from</code> to <code class="param">to</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>the first value </td></tr>
    <tr><td class="paramname">to</td><td>the second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if its safe to convert from <code class="param">from</code> to <code class="param">to</code>, false otherwise.</dd></dl>
<p>if the function returns true, then it is safe to use <code class="param">to</code>. If the function returns false, then <code class="param">to</code> is undefined and should not be used. </p><dl class="section since"><dt>Since</dt><dd>Crypto++ 8.8 </dd></dl>

</div>
</div>
<a id="a7808d89c7ac5c2c77360944dc7369678" name="a7808d89c7ac5c2c77360944dc7369678"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7808d89c7ac5c2c77360944dc7369678">&#9670;&#160;</a></span>SafeConvert() <span class="overload">[10/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SafeConvert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a></td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word64 &amp;</td>          <td class="paramname"><span class="paramname"><em>to</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a conversion from <code class="param">from</code> to <code class="param">to</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>the first value </td></tr>
    <tr><td class="paramname">to</td><td>the second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if its safe to convert from <code class="param">from</code> to <code class="param">to</code>, false otherwise.</dd></dl>
<p>if the function returns true, then it is safe to use <code class="param">to</code>. If the function returns false, then <code class="param">to</code> is undefined and should not be used. </p><dl class="section since"><dt>Since</dt><dd>Crypto++ 8.8 </dd></dl>

</div>
</div>
<a id="adb7c3d4c147bee46750037a346059815" name="adb7c3d4c147bee46750037a346059815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb7c3d4c147bee46750037a346059815">&#9670;&#160;</a></span>SafeConvert() <span class="overload">[11/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SafeConvert </td>
          <td>(</td>
          <td class="paramtype">word64</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a3304866b527056436d1a444813cd5f6d">sword32</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>to</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a conversion from <code class="param">from</code> to <code class="param">to</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>the first value </td></tr>
    <tr><td class="paramname">to</td><td>the second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if its safe to convert from <code class="param">from</code> to <code class="param">to</code>, false otherwise.</dd></dl>
<p>if the function returns true, then it is safe to use <code class="param">to</code>. If the function returns false, then <code class="param">to</code> is undefined and should not be used. </p><dl class="section since"><dt>Since</dt><dd>Crypto++ 8.8 </dd></dl>

</div>
</div>
<a id="a9b7e594dd086ec2ae625cbcf7fe71b5f" name="a9b7e594dd086ec2ae625cbcf7fe71b5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b7e594dd086ec2ae625cbcf7fe71b5f">&#9670;&#160;</a></span>SafeConvert() <span class="overload">[12/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SafeConvert </td>
          <td>(</td>
          <td class="paramtype">word64</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sword64 &amp;</td>          <td class="paramname"><span class="paramname"><em>to</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a conversion from <code class="param">from</code> to <code class="param">to</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>the first value </td></tr>
    <tr><td class="paramname">to</td><td>the second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if its safe to convert from <code class="param">from</code> to <code class="param">to</code>, false otherwise.</dd></dl>
<p>if the function returns true, then it is safe to use <code class="param">to</code>. If the function returns false, then <code class="param">to</code> is undefined and should not be used. </p><dl class="section since"><dt>Since</dt><dd>Crypto++ 8.8 </dd></dl>

</div>
</div>
<a id="ac7c1d152be686ca1f2e017d226915468" name="ac7c1d152be686ca1f2e017d226915468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7c1d152be686ca1f2e017d226915468">&#9670;&#160;</a></span>SafeConvert() <span class="overload">[13/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SafeConvert </td>
          <td>(</td>
          <td class="paramtype">word64</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>to</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a conversion from <code class="param">from</code> to <code class="param">to</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>the first value </td></tr>
    <tr><td class="paramname">to</td><td>the second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if its safe to convert from <code class="param">from</code> to <code class="param">to</code>, false otherwise.</dd></dl>
<p>if the function returns true, then it is safe to use <code class="param">to</code>. If the function returns false, then <code class="param">to</code> is undefined and should not be used. </p><dl class="section since"><dt>Since</dt><dd>Crypto++ 8.8 </dd></dl>

</div>
</div>
<a id="a45e2662974095094e345b2bc2b30ee4c" name="a45e2662974095094e345b2bc2b30ee4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45e2662974095094e345b2bc2b30ee4c">&#9670;&#160;</a></span>SafeLeftShift()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int bits, class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T SafeLeftShift </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Safely left shift values when undefined behavior could occur. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bits</td><td>the number of bit positions to shift the value </td></tr>
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to left shift </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the shifted value or 0</dd></dl>
<p>SafeLeftShift safely shifts the value to the left when undefined behavior could occur under C/C++ rules. SafeLeftShift will return the shifted value or 0 if undefined behavior would occur. </p>

</div>
</div>
<a id="abda5071e4c754b612b6a4c42be421312" name="abda5071e4c754b612b6a4c42be421312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abda5071e4c754b612b6a4c42be421312">&#9670;&#160;</a></span>SafeRightShift()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int bits, class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T SafeRightShift </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Safely right shift values when undefined behavior could occur. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bits</td><td>the number of bit positions to shift the value </td></tr>
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to right shift </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the shifted value or 0</dd></dl>
<p>SafeRightShift safely shifts the value to the right when undefined behavior could occur under C/C++ rules. SafeRightShift will return the shifted value or 0 if undefined behavior would occur. </p>

</div>
</div>
<a id="a30712a90999ad9d9152975f2e92d46b8" name="a30712a90999ad9d9152975f2e92d46b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30712a90999ad9d9152975f2e92d46b8">&#9670;&#160;</a></span>SaturatingSubtract()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T1 SaturatingSubtract </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a saturating subtract clamped at 0. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>class or type </td></tr>
    <tr><td class="paramname">T2</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the minuend </td></tr>
    <tr><td class="paramname">b</td><td>the subtrahend </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the difference produced by the saturating subtract</dd></dl>
<p>Saturating arithmetic restricts results to a fixed range. Results that are less than 0 are clamped at 0.</p>
<p>Use of saturating arithmetic in places can be advantageous because it can avoid a branch by using an instruction like a conditional move (<code>CMOVE</code>). </p>

</div>
</div>
<a id="afd39d67faef904dbb474981762b7ebe1" name="afd39d67faef904dbb474981762b7ebe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd39d67faef904dbb474981762b7ebe1">&#9670;&#160;</a></span>SaturatingSubtract1()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T1 SaturatingSubtract1 </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a saturating subtract clamped at 1. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>class or type </td></tr>
    <tr><td class="paramname">T2</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the minuend </td></tr>
    <tr><td class="paramname">b</td><td>the subtrahend </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the difference produced by the saturating subtract</dd></dl>
<p>Saturating arithmetic restricts results to a fixed range. Results that are less than 1 are clamped at 1.</p>
<p>Use of saturating arithmetic in places can be advantageous because it can avoid a branch by using an instruction like a conditional move (<code>CMOVE</code>). </p>

</div>
</div>
<a id="a4994f3480634e5f1435fd71f9b652c38" name="a4994f3480634e5f1435fd71f9b652c38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4994f3480634e5f1435fd71f9b652c38">&#9670;&#160;</a></span>SecureWipeArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SecureWipeArray </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets each element of an array to 0. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>an array of elements </td></tr>
    <tr><td class="paramname">n</td><td>the number of elements in the array</td></tr>
  </table>
  </dd>
</dl>
<p>The operation performs a wipe or zeroization. The function attempts to survive optimizations and dead code removal. </p>

</div>
</div>
<a id="a656f38b8d0440981f5f013ada782018c" name="a656f38b8d0440981f5f013ada782018c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a656f38b8d0440981f5f013ada782018c">&#9670;&#160;</a></span>SecureWipeBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SecureWipeBuffer </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets each element of an array to 0. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>an array of elements </td></tr>
    <tr><td class="paramname">n</td><td>the number of elements in the array</td></tr>
  </table>
  </dd>
</dl>
<p>The operation performs a wipe or zeroization. The function attempts to survive optimizations and dead code removal. </p>

</div>
</div>
<a id="a3666860179c072fc5222f9b6dacefcb5" name="a3666860179c072fc5222f9b6dacefcb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3666860179c072fc5222f9b6dacefcb5">&#9670;&#160;</a></span>STDMAX()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; STDMAX </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replacement function for std::max. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first value </td></tr>
    <tr><td class="paramname">b</td><td>the second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the minimum value based on a comparison of <code>a &lt; b</code> using <code>operator&lt;</code></dd></dl>
<p>STDMAX was provided because the library could not easily use std::min or std::max in Windows or Cygwin 1.1.0 </p>

</div>
</div>
<a id="a6870af46b8ad78fd77c724d9ccd48fdc" name="a6870af46b8ad78fd77c724d9ccd48fdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6870af46b8ad78fd77c724d9ccd48fdc">&#9670;&#160;</a></span>STDMIN()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; STDMIN </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replacement function for std::min. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first value </td></tr>
    <tr><td class="paramname">b</td><td>the second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the minimum value based on a comparison of <code>b &lt; a</code> using <code>operator&lt;</code></dd></dl>
<p>STDMIN was provided because the library could not easily use std::min or std::max in Windows or Cygwin 1.1.0 </p>

</div>
</div>
<a id="aba2ed56f8a15d6dabbef74390eda4352" name="aba2ed56f8a15d6dabbef74390eda4352"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba2ed56f8a15d6dabbef74390eda4352">&#9670;&#160;</a></span>StringNarrow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string StringNarrow </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>throwOnError</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a wide character C-string to a multibyte string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>C-string consisting of wide characters </td></tr>
    <tr><td class="paramname">throwOnError</td><td>flag indicating the function should throw on error </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>str converted to a multibyte string or an empty string.</dd></dl>
<p><a class="el" href="include_2cryptopp_2misc_8h.html#aba2ed56f8a15d6dabbef74390eda4352" title="Converts a wide character C-string to a multibyte string.">StringNarrow()</a> converts a wide string to a narrow string using C++ std::wcstombs() under the executing thread's locale. A locale must be set before using this function, and it can be set with std::setlocale() if needed. Upon success, the converted string is returned.</p>
<p>Upon failure with throwOnError as false, the function returns an empty string. If throwOnError as true, the function throws an <a class="el" href="class_invalid_argument.html" title="An invalid argument was detected.">InvalidArgument()</a> exception. </p><dl class="section note"><dt>Note</dt><dd>If you try to convert, say, the Chinese character for "bone" from UTF-16 (0x9AA8) to UTF-8 (0xE9 0xAA 0xA8), then you must ensure the locale is available. If the locale is not available, then a 0x21 error is returned on Windows which eventually results in an <a class="el" href="class_invalid_argument.html" title="An invalid argument was detected.">InvalidArgument()</a> exception. </dd></dl>

</div>
</div>
<a id="a23234e96107b28512db9467c33f67590" name="a23234e96107b28512db9467c33f67590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23234e96107b28512db9467c33f67590">&#9670;&#160;</a></span>StringToWord()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T StringToWord </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142baf0c3bb6c718cc7ff0bffef4e8f178c57">BIG_ENDIAN_ORDER</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a string to a word. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert </td></tr>
    <tr><td class="paramname">order</td><td>byte order </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a word representing the value of the string </dd></dl>

</div>
</div>
<a id="ac95ff706a83782e3d18a3d14817db932" name="ac95ff706a83782e3d18a3d14817db932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac95ff706a83782e3d18a3d14817db932">&#9670;&#160;</a></span>StringWiden()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::wstring StringWiden </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>throwOnError</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a multibyte C-string to a wide character string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>C-string consisting of wide characters </td></tr>
    <tr><td class="paramname">throwOnError</td><td>flag indicating the function should throw on error </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>str converted to a multibyte string or an empty string.</dd></dl>
<p><a class="el" href="include_2cryptopp_2misc_8h.html#ac95ff706a83782e3d18a3d14817db932" title="Converts a multibyte C-string to a wide character string.">StringWiden()</a> converts a narrow string to a wide string using C++ std::mbstowcs() under the executing thread's locale. A locale must be set before using this function, and it can be set with std::setlocale() if needed. Upon success, the converted string is returned.</p>
<p>Upon failure with throwOnError as false, the function returns an empty string. If throwOnError as true, the function throws an <a class="el" href="class_invalid_argument.html" title="An invalid argument was detected.">InvalidArgument()</a> exception. </p><dl class="section note"><dt>Note</dt><dd>If you try to convert, say, the Chinese character for "bone" from UTF-8 (0xE9 0xAA 0xA8) to UTF-16 (0x9AA8), then you must ensure the locale is available. If the locale is not available, then a 0x21 error is returned on Windows which eventually results in an <a class="el" href="class_invalid_argument.html" title="An invalid argument was detected.">InvalidArgument()</a> exception. </dd></dl>

</div>
</div>
<a id="a495acbd6f3cdabbb4dd863c09b378df4" name="a495acbd6f3cdabbb4dd863c09b378df4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a495acbd6f3cdabbb4dd863c09b378df4">&#9670;&#160;</a></span>TrailingZeros() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int TrailingZeros </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determines the number of trailing 0-bits in a value </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>the 32-bit value to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of trailing 0-bits in v, starting at the least significant bit position</dd></dl>
<p>TrailingZeros returns the number of trailing 0-bits in v, starting at the least significant bit position. The return value is undefined if there are no 1-bits set in the value v. </p><dl class="section note"><dt>Note</dt><dd>The function does not return 0 if no 1-bits are set because 0 collides with a 1-bit at the 0-th position. </dd></dl>

</div>
</div>
<a id="addb4df9b2f1e119d89a1573338c4eda6" name="addb4df9b2f1e119d89a1573338c4eda6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addb4df9b2f1e119d89a1573338c4eda6">&#9670;&#160;</a></span>TrailingZeros() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int TrailingZeros </td>
          <td>(</td>
          <td class="paramtype">word64</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determines the number of trailing 0-bits in a value </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>the 64-bit value to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of trailing 0-bits in v, starting at the least significant bit position</dd></dl>
<p>TrailingZeros returns the number of trailing 0-bits in v, starting at the least significant bit position. The return value is undefined if there are no 1-bits set in the value v. </p><dl class="section note"><dt>Note</dt><dd>The function does not return 0 if no 1-bits are set because 0 collides with a 1-bit at the 0-th position. </dd></dl>

</div>
</div>
<a id="a8184a77f9a4c8ffbda9622b1cee7a148" name="a8184a77f9a4c8ffbda9622b1cee7a148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8184a77f9a4c8ffbda9622b1cee7a148">&#9670;&#160;</a></span>UnalignedbyteNonTemplate() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UnalignedbyteNonTemplate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *</td>          <td class="paramname"><span class="paramname"><em>block</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *</td>          <td class="paramname"><span class="paramname"><em>xorBlock</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a byte to an unaligned buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>the <a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b" title="Provides the byte ordering.">ByteOrder</a> of the data </td></tr>
    <tr><td class="paramname">block</td><td>an unaligned output buffer </td></tr>
    <tr><td class="paramname">value</td><td>byte value </td></tr>
    <tr><td class="paramname">xorBlock</td><td>optional unaligned xor buffer</td></tr>
  </table>
  </dd>
</dl>
<p>UnalignedbyteNonTemplate writes a byte value to an unaligned buffer. </p><dl class="section since"><dt>Since</dt><dd>Crypto++ 1.0 </dd></dl>

</div>
</div>
<a id="ac26b43699857ac54a8f4624c89bb6ab9" name="ac26b43699857ac54a8f4624c89bb6ab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac26b43699857ac54a8f4624c89bb6ab9">&#9670;&#160;</a></span>UnalignedbyteNonTemplate() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UnalignedbyteNonTemplate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *</td>          <td class="paramname"><span class="paramname"><em>block</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#ac32ea9831f54b53dfce00081c0d02681">word16</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *</td>          <td class="paramname"><span class="paramname"><em>xorBlock</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a <a class="el" href="config__int_8h.html#ac32ea9831f54b53dfce00081c0d02681" title="16-bit unsigned datatype">word16</a> to an unaligned buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>the <a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b" title="Provides the byte ordering.">ByteOrder</a> of the data </td></tr>
    <tr><td class="paramname">block</td><td>an unaligned output buffer </td></tr>
    <tr><td class="paramname">value</td><td><a class="el" href="config__int_8h.html#ac32ea9831f54b53dfce00081c0d02681" title="16-bit unsigned datatype">word16</a> value </td></tr>
    <tr><td class="paramname">xorBlock</td><td>optional unaligned xor buffer</td></tr>
  </table>
  </dd>
</dl>
<p>UnalignedbyteNonTemplate writes a <a class="el" href="config__int_8h.html#ac32ea9831f54b53dfce00081c0d02681" title="16-bit unsigned datatype">word16</a> value to an unaligned buffer. </p><dl class="section since"><dt>Since</dt><dd>Crypto++ 1.0 </dd></dl>

</div>
</div>
<a id="aef9d0bbf3f776108244b5c36ff5041d5" name="aef9d0bbf3f776108244b5c36ff5041d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef9d0bbf3f776108244b5c36ff5041d5">&#9670;&#160;</a></span>UnalignedbyteNonTemplate() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UnalignedbyteNonTemplate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *</td>          <td class="paramname"><span class="paramname"><em>block</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *</td>          <td class="paramname"><span class="paramname"><em>xorBlock</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a <a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d" title="32-bit unsigned datatype">word32</a> to an unaligned buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>the <a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b" title="Provides the byte ordering.">ByteOrder</a> of the data </td></tr>
    <tr><td class="paramname">block</td><td>an unaligned output buffer </td></tr>
    <tr><td class="paramname">value</td><td><a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d" title="32-bit unsigned datatype">word32</a> value </td></tr>
    <tr><td class="paramname">xorBlock</td><td>optional unaligned xor buffer</td></tr>
  </table>
  </dd>
</dl>
<p>UnalignedbyteNonTemplate writes a <a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d" title="32-bit unsigned datatype">word32</a> value to an unaligned buffer. </p><dl class="section since"><dt>Since</dt><dd>Crypto++ 1.0 </dd></dl>

</div>
</div>
<a id="a36bf3fa1752839aa454537cd2d3ca935" name="a36bf3fa1752839aa454537cd2d3ca935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36bf3fa1752839aa454537cd2d3ca935">&#9670;&#160;</a></span>UnalignedbyteNonTemplate() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UnalignedbyteNonTemplate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *</td>          <td class="paramname"><span class="paramname"><em>block</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word64</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *</td>          <td class="paramname"><span class="paramname"><em>xorBlock</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a word64 to an unaligned buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>the <a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b" title="Provides the byte ordering.">ByteOrder</a> of the data </td></tr>
    <tr><td class="paramname">block</td><td>an unaligned output buffer </td></tr>
    <tr><td class="paramname">value</td><td>word64 value </td></tr>
    <tr><td class="paramname">xorBlock</td><td>optional unaligned xor buffer</td></tr>
  </table>
  </dd>
</dl>
<p>UnalignedbyteNonTemplate writes a word64 value to an unaligned buffer. </p><dl class="section since"><dt>Since</dt><dd>Crypto++ 1.0 </dd></dl>

</div>
</div>
<a id="ab4ded795b6a29f00d160d123480d279d" name="ab4ded795b6a29f00d160d123480d279d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4ded795b6a29f00d160d123480d279d">&#9670;&#160;</a></span>UnalignedGetWordNonTemplate() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> UnalignedGetWordNonTemplate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *</td>          <td class="paramname"><span class="paramname"><em>block</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *</td>          <td class="paramname"><span class="paramname"><em>unused</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a byte from an unaligned buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>the <a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b" title="Provides the byte ordering.">ByteOrder</a> of the data </td></tr>
    <tr><td class="paramname">block</td><td>an unaligned buffer </td></tr>
    <tr><td class="paramname">unused</td><td>dummy parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>byte value</dd></dl>
<p>UnalignedGetWordNonTemplate accesses an unaligned buffer and returns a byte value. </p><dl class="section since"><dt>Since</dt><dd>Crypto++ 1.0 </dd></dl>

</div>
</div>
<a id="aa30f251bbb592f2d1621d8c37dffcf8a" name="aa30f251bbb592f2d1621d8c37dffcf8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa30f251bbb592f2d1621d8c37dffcf8a">&#9670;&#160;</a></span>UnalignedGetWordNonTemplate() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config__int_8h.html#ac32ea9831f54b53dfce00081c0d02681">word16</a> UnalignedGetWordNonTemplate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *</td>          <td class="paramname"><span class="paramname"><em>block</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#ac32ea9831f54b53dfce00081c0d02681">word16</a> *</td>          <td class="paramname"><span class="paramname"><em>unused</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a <a class="el" href="config__int_8h.html#ac32ea9831f54b53dfce00081c0d02681" title="16-bit unsigned datatype">word16</a> from an unaligned buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>the <a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b" title="Provides the byte ordering.">ByteOrder</a> of the data </td></tr>
    <tr><td class="paramname">block</td><td>an unaligned buffer </td></tr>
    <tr><td class="paramname">unused</td><td>dummy parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>byte value</dd></dl>
<p>UnalignedGetWordNonTemplate accesses an unaligned buffer and returns a <a class="el" href="config__int_8h.html#ac32ea9831f54b53dfce00081c0d02681" title="16-bit unsigned datatype">word16</a> value. </p><dl class="section since"><dt>Since</dt><dd>Crypto++ 1.0 </dd></dl>

</div>
</div>
<a id="ad7c7e2905abe7b50b0c49f78ea7fcb71" name="ad7c7e2905abe7b50b0c49f78ea7fcb71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7c7e2905abe7b50b0c49f78ea7fcb71">&#9670;&#160;</a></span>UnalignedGetWordNonTemplate() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a> UnalignedGetWordNonTemplate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *</td>          <td class="paramname"><span class="paramname"><em>block</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a> *</td>          <td class="paramname"><span class="paramname"><em>unused</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a <a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d" title="32-bit unsigned datatype">word32</a> from an unaligned buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>the <a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b" title="Provides the byte ordering.">ByteOrder</a> of the data </td></tr>
    <tr><td class="paramname">block</td><td>an unaligned buffer </td></tr>
    <tr><td class="paramname">unused</td><td>dummy parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>byte value</dd></dl>
<p>UnalignedGetWordNonTemplate accesses an unaligned buffer and returns a <a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d" title="32-bit unsigned datatype">word32</a> value. </p><dl class="section since"><dt>Since</dt><dd>Crypto++ 1.0 </dd></dl>

</div>
</div>
<a id="a8d6f65b550c7f363ba6d36ab1f5323c5" name="a8d6f65b550c7f363ba6d36ab1f5323c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d6f65b550c7f363ba6d36ab1f5323c5">&#9670;&#160;</a></span>UnalignedGetWordNonTemplate() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">word64 UnalignedGetWordNonTemplate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *</td>          <td class="paramname"><span class="paramname"><em>block</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const word64 *</td>          <td class="paramname"><span class="paramname"><em>unused</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a word64 from an unaligned buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>the <a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b" title="Provides the byte ordering.">ByteOrder</a> of the data </td></tr>
    <tr><td class="paramname">block</td><td>an unaligned buffer </td></tr>
    <tr><td class="paramname">unused</td><td>dummy parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>byte value</dd></dl>
<p>UnalignedGetWordNonTemplate accesses an unaligned buffer and returns a word64 value. </p><dl class="section since"><dt>Since</dt><dd>Crypto++ 1.0 </dd></dl>

</div>
</div>
<a id="ac8391e7d9d613a6c401787d2cdab1f51" name="ac8391e7d9d613a6c401787d2cdab1f51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8391e7d9d613a6c401787d2cdab1f51">&#9670;&#160;</a></span>UnsignedMin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T1 UnsignedMin </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Safe comparison of values that could be negative and incorrectly promoted. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>class or type </td></tr>
    <tr><td class="paramname">T2</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first value </td></tr>
    <tr><td class="paramname">b</td><td>the second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the minimum value based on a comparison a and b using <code>operator&lt;</code>.</dd></dl>
<p>The comparison <code>b &lt; a</code> is performed and the value returned is type T1. </p>

</div>
</div>
<a id="a810542d642def73fd278c08092417e11" name="a810542d642def73fd278c08092417e11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a810542d642def73fd278c08092417e11">&#9670;&#160;</a></span>vec_swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vec_swap </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps two variables which are arrays. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first value </td></tr>
    <tr><td class="paramname">b</td><td>the second value</td></tr>
  </table>
  </dd>
</dl>
<p>C++03 does not provide support for <code>std::swap(__m128i a, __m128i b)</code> because <code>__m128i</code> is an <code>unsigned long long[2]</code>. Most compilers support it out of the box, but Sun Studio C++ compilers 12.2 and 12.3 do not. </p><dl class="section see"><dt>See also</dt><dd><a href="http://stackoverflow.com/q/38417413">How to swap two __m128i variables in C++03 given its an opaque type and an array?</a> on Stack Overflow. </dd></dl>

</div>
</div>
<a id="a9f1c626f8d491a96c517b5a165b60be5" name="a9f1c626f8d491a96c517b5a165b60be5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f1c626f8d491a96c517b5a165b60be5">&#9670;&#160;</a></span>VerifyBufsEqual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CRYPTOPP_DLL bool CRYPTOPP_API VerifyBufsEqual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *</td>          <td class="paramname"><span class="paramname"><em>buf1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *</td>          <td class="paramname"><span class="paramname"><em>buf2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a near constant-time comparison of two equally sized buffers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf1</td><td>the first buffer </td></tr>
    <tr><td class="paramname">buf2</td><td>the second buffer </td></tr>
    <tr><td class="paramname">count</td><td>the size of the buffers, in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>VerifyBufsEqual performs an XOR of the elements in two equally sized buffers and returns a result based on the XOR operation. A count of 0 returns true because two empty buffers are considered equal.</p>
<p>The function is near constant-time because CPU micro-code timings could affect the "constant-ness". Calling code is responsible for mitigating timing attacks if the buffers are not equally sized. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="include_2cryptopp_2misc_8h.html#a621695f6346d6a745e340513d917b31a" title="Reduces a value to a power of 2.">ModPowerOf2</a> </dd></dl>

</div>
</div>
<a id="a18a35b59a1f2e23b94ed2f74f0594613" name="a18a35b59a1f2e23b94ed2f74f0594613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18a35b59a1f2e23b94ed2f74f0594613">&#9670;&#160;</a></span>WordToString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string WordToString </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142baf0c3bb6c718cc7ff0bffef4e8f178c57">BIG_ENDIAN_ORDER</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a word to a string. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the word to convert </td></tr>
    <tr><td class="paramname">order</td><td>byte order </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string representing the value of the word </dd></dl>

</div>
</div>
<a id="a7d2088e041288c140d06e1fba844e6e9" name="a7d2088e041288c140d06e1fba844e6e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d2088e041288c140d06e1fba844e6e9">&#9670;&#160;</a></span>xorbuf() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CRYPTOPP_DLL void CRYPTOPP_API xorbuf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *</td>          <td class="paramname"><span class="paramname"><em>mask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs an XOR of a buffer with a mask </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the buffer to XOR with the mask </td></tr>
    <tr><td class="paramname">mask</td><td>the mask to XOR with the buffer </td></tr>
    <tr><td class="paramname">count</td><td>the size of the buffers, in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>The function effectively visits each element in the buffers and performs <code>buf[i] ^= mask[i]</code>. buf and mask must be of equal size. </p>

</div>
</div>
<a id="a4db8a951de8dbc133bc845e21d2c59ae" name="a4db8a951de8dbc133bc845e21d2c59ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4db8a951de8dbc133bc845e21d2c59ae">&#9670;&#160;</a></span>xorbuf() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CRYPTOPP_DLL void CRYPTOPP_API xorbuf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *</td>          <td class="paramname"><span class="paramname"><em>output</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *</td>          <td class="paramname"><span class="paramname"><em>mask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs an XOR of an input buffer with a mask and stores the result in an output buffer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>the destination buffer </td></tr>
    <tr><td class="paramname">input</td><td>the source buffer to XOR with the mask </td></tr>
    <tr><td class="paramname">mask</td><td>the mask buffer to XOR with the input buffer </td></tr>
    <tr><td class="paramname">count</td><td>the size of the buffers, in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>The function effectively visits each element in the buffers and performs <code>output[i] = input[i] ^ mask[i]</code>. output, input and mask must be of equal size. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_e6bb53534ac0e427887cf7a94c0c004e.html">C:</a></li><li class="navelem"><a class="el" href="dir_8ceffd4ee35c3518d4e8bdc7e638efe8.html">Users</a></li><li class="navelem"><a class="el" href="dir_61a8197785bcaa1e34766e6c335af32d.html">Admin</a></li><li class="navelem"><a class="el" href="dir_a3654859eba761e9b36a225ee7d3b3a0.html">Downloads</a></li><li class="navelem"><a class="el" href="dir_9d3215f5f7acae6cf06befdd7fa10a7a.html">NT219</a></li><li class="navelem"><a class="el" href="dir_7393c9baa1ace000a94625aadf8229a7.html">cryptopp</a></li><li class="navelem"><a class="el" href="misc_8h.html">misc.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
