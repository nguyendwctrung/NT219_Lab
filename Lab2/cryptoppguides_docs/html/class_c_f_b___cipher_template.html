<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Crypto++ Library: CFB_CipherTemplate&lt; BASE &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Crypto++ Library
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('class_c_f_b___cipher_template.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_c_f_b___cipher_template-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">CFB_CipherTemplate&lt; BASE &gt; Class Template Reference<span class="mlabels"><span class="mlabel abstract">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Base class for feedback based stream ciphers with <a class="el" href="class_symmetric_cipher.html" title="Interface for one direction (encryption or decryption) of a stream cipher or cipher mode.">SymmetricCipher</a> interface.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="include_2cryptopp_2strciphr_8h_source.html">strciphr.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for CFB_CipherTemplate&lt; BASE &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_c_f_b___cipher_template.png" usemap="#CFB_5FCipherTemplate_3C_20BASE_20_3E_map" alt=""/>
  <map id="CFB_5FCipherTemplate_3C_20BASE_20_3E_map" name="CFB_5FCipherTemplate_3C_20BASE_20_3E_map">
<area href="class_c_f_b___decryption_template.html" title="Base class for feedback based stream ciphers in the reverse direction with SymmetricCipher interface." alt="CFB_DecryptionTemplate&lt; BASE &gt;" shape="rect" coords="0,112,213,136"/>
<area href="class_c_f_b___decryption_template.html" title="Base class for feedback based stream ciphers in the reverse direction with SymmetricCipher interface." alt="CFB_DecryptionTemplate&lt; BASE &gt;" shape="rect" coords="223,112,436,136"/>
<area href="class_c_f_b___encryption_template.html" title="Base class for feedback based stream ciphers in the forward direction with SymmetricCipher interface." alt="CFB_EncryptionTemplate&lt; BASE &gt;" shape="rect" coords="446,112,659,136"/>
<area href="class_c_f_b___encryption_template.html" title="Base class for feedback based stream ciphers in the forward direction with SymmetricCipher interface." alt="CFB_EncryptionTemplate&lt; BASE &gt;" shape="rect" coords="669,112,882,136"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9e72e3524dd351fd0e87382fe84cd306" id="r_a9e72e3524dd351fd0e87382fe84cd306"><td class="memItemLeft" align="right" valign="top"><a id="a9e72e3524dd351fd0e87382fe84cd306" name="a9e72e3524dd351fd0e87382fe84cd306"></a>
typedef BASE::PolicyInterface&#160;</td><td class="memItemRight" valign="bottom"><b>PolicyInterface</b></td></tr>
<tr class="separator:a9e72e3524dd351fd0e87382fe84cd306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e72e3524dd351fd0e87382fe84cd306" id="r_a9e72e3524dd351fd0e87382fe84cd306"><td class="memItemLeft" align="right" valign="top"><a id="a9e72e3524dd351fd0e87382fe84cd306" name="a9e72e3524dd351fd0e87382fe84cd306"></a>
typedef BASE::PolicyInterface&#160;</td><td class="memItemRight" valign="bottom"><b>PolicyInterface</b></td></tr>
<tr class="separator:a9e72e3524dd351fd0e87382fe84cd306"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adf14a759fd95fd687f4e257264771f89" id="r_adf14a759fd95fd687f4e257264771f89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf14a759fd95fd687f4e257264771f89">ProcessData</a> (<a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *outString, const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *inString, size_t length)</td></tr>
<tr class="memdesc:adf14a759fd95fd687f4e257264771f89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply keystream to data.  <br /></td></tr>
<tr class="separator:adf14a759fd95fd687f4e257264771f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8604f13ab0f11d510c8e1f28526333a0" id="r_a8604f13ab0f11d510c8e1f28526333a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8604f13ab0f11d510c8e1f28526333a0">Resynchronize</a> (const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *iv, int length=-1)</td></tr>
<tr class="memdesc:a8604f13ab0f11d510c8e1f28526333a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resynchronize the cipher.  <br /></td></tr>
<tr class="separator:a8604f13ab0f11d510c8e1f28526333a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3055f5f53d6770aacfb4c042f75e5dab" id="r_a3055f5f53d6770aacfb4c042f75e5dab"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3055f5f53d6770aacfb4c042f75e5dab">OptimalBlockSize</a> () const</td></tr>
<tr class="memdesc:a3055f5f53d6770aacfb4c042f75e5dab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides number of ideal bytes to process.  <br /></td></tr>
<tr class="separator:a3055f5f53d6770aacfb4c042f75e5dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adae738b3fbef96cb5ed6c0f37f6e9621" id="r_adae738b3fbef96cb5ed6c0f37f6e9621"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adae738b3fbef96cb5ed6c0f37f6e9621">GetOptimalNextBlockSize</a> () const</td></tr>
<tr class="memdesc:adae738b3fbef96cb5ed6c0f37f6e9621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides number of ideal bytes to process.  <br /></td></tr>
<tr class="separator:adae738b3fbef96cb5ed6c0f37f6e9621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3efd5acd93a2e3601d80bbbf9beaaf1d" id="r_a3efd5acd93a2e3601d80bbbf9beaaf1d"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3efd5acd93a2e3601d80bbbf9beaaf1d">OptimalDataAlignment</a> () const</td></tr>
<tr class="memdesc:a3efd5acd93a2e3601d80bbbf9beaaf1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides number of ideal data alignment.  <br /></td></tr>
<tr class="separator:a3efd5acd93a2e3601d80bbbf9beaaf1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71489329f90306fbf7916335b9bc0ca9" id="r_a71489329f90306fbf7916335b9bc0ca9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71489329f90306fbf7916335b9bc0ca9">IsRandomAccess</a> () const</td></tr>
<tr class="memdesc:a71489329f90306fbf7916335b9bc0ca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag indicating random access.  <br /></td></tr>
<tr class="separator:a71489329f90306fbf7916335b9bc0ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add3c4fa05f62c3e601faa4a469ee108d" id="r_add3c4fa05f62c3e601faa4a469ee108d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add3c4fa05f62c3e601faa4a469ee108d">IsSelfInverting</a> () const</td></tr>
<tr class="memdesc:add3c4fa05f62c3e601faa4a469ee108d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the cipher is self inverting.  <br /></td></tr>
<tr class="separator:add3c4fa05f62c3e601faa4a469ee108d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f4c5691e5061fe3e0c2e161689b969e" id="r_a1f4c5691e5061fe3e0c2e161689b969e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f4c5691e5061fe3e0c2e161689b969e">AlgorithmProvider</a> () const</td></tr>
<tr class="memdesc:a1f4c5691e5061fe3e0c2e161689b969e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the provider of this algorithm.  <br /></td></tr>
<tr class="separator:a1f4c5691e5061fe3e0c2e161689b969e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf14a759fd95fd687f4e257264771f89" id="r_adf14a759fd95fd687f4e257264771f89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf14a759fd95fd687f4e257264771f89">ProcessData</a> (<a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *outString, const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *inString, size_t length)</td></tr>
<tr class="memdesc:adf14a759fd95fd687f4e257264771f89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply keystream to data.  <br /></td></tr>
<tr class="separator:adf14a759fd95fd687f4e257264771f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8604f13ab0f11d510c8e1f28526333a0" id="r_a8604f13ab0f11d510c8e1f28526333a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8604f13ab0f11d510c8e1f28526333a0">Resynchronize</a> (const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *iv, int length=-1)</td></tr>
<tr class="memdesc:a8604f13ab0f11d510c8e1f28526333a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resynchronize the cipher.  <br /></td></tr>
<tr class="separator:a8604f13ab0f11d510c8e1f28526333a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3055f5f53d6770aacfb4c042f75e5dab" id="r_a3055f5f53d6770aacfb4c042f75e5dab"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3055f5f53d6770aacfb4c042f75e5dab">OptimalBlockSize</a> () const</td></tr>
<tr class="memdesc:a3055f5f53d6770aacfb4c042f75e5dab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides number of ideal bytes to process.  <br /></td></tr>
<tr class="separator:a3055f5f53d6770aacfb4c042f75e5dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adae738b3fbef96cb5ed6c0f37f6e9621" id="r_adae738b3fbef96cb5ed6c0f37f6e9621"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adae738b3fbef96cb5ed6c0f37f6e9621">GetOptimalNextBlockSize</a> () const</td></tr>
<tr class="memdesc:adae738b3fbef96cb5ed6c0f37f6e9621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides number of ideal bytes to process.  <br /></td></tr>
<tr class="separator:adae738b3fbef96cb5ed6c0f37f6e9621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3efd5acd93a2e3601d80bbbf9beaaf1d" id="r_a3efd5acd93a2e3601d80bbbf9beaaf1d"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3efd5acd93a2e3601d80bbbf9beaaf1d">OptimalDataAlignment</a> () const</td></tr>
<tr class="memdesc:a3efd5acd93a2e3601d80bbbf9beaaf1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides number of ideal data alignment.  <br /></td></tr>
<tr class="separator:a3efd5acd93a2e3601d80bbbf9beaaf1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71489329f90306fbf7916335b9bc0ca9" id="r_a71489329f90306fbf7916335b9bc0ca9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71489329f90306fbf7916335b9bc0ca9">IsRandomAccess</a> () const</td></tr>
<tr class="memdesc:a71489329f90306fbf7916335b9bc0ca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag indicating random access.  <br /></td></tr>
<tr class="separator:a71489329f90306fbf7916335b9bc0ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add3c4fa05f62c3e601faa4a469ee108d" id="r_add3c4fa05f62c3e601faa4a469ee108d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add3c4fa05f62c3e601faa4a469ee108d">IsSelfInverting</a> () const</td></tr>
<tr class="memdesc:add3c4fa05f62c3e601faa4a469ee108d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the cipher is self inverting.  <br /></td></tr>
<tr class="separator:add3c4fa05f62c3e601faa4a469ee108d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f4c5691e5061fe3e0c2e161689b969e" id="r_a1f4c5691e5061fe3e0c2e161689b969e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f4c5691e5061fe3e0c2e161689b969e">AlgorithmProvider</a> () const</td></tr>
<tr class="memdesc:a1f4c5691e5061fe3e0c2e161689b969e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the provider of this algorithm.  <br /></td></tr>
<tr class="separator:a1f4c5691e5061fe3e0c2e161689b969e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a09a7d08859049cefee1dc46b5a405805" id="r_a09a7d08859049cefee1dc46b5a405805"><td class="memItemLeft" align="right" valign="top"><a id="a09a7d08859049cefee1dc46b5a405805" name="a09a7d08859049cefee1dc46b5a405805"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>CombineMessageAndShiftRegister</b> (<a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *output, <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *reg, const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *message, size_t length)=0</td></tr>
<tr class="separator:a09a7d08859049cefee1dc46b5a405805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb03ad65083bbba86bdffcaf5d79da6" id="r_aecb03ad65083bbba86bdffcaf5d79da6"><td class="memItemLeft" align="right" valign="top"><a id="aecb03ad65083bbba86bdffcaf5d79da6" name="aecb03ad65083bbba86bdffcaf5d79da6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>UncheckedSetKey</b> (const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *key, unsigned int length, const <a class="el" href="class_name_value_pairs.html">NameValuePairs</a> &amp;params)</td></tr>
<tr class="separator:aecb03ad65083bbba86bdffcaf5d79da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a7d08859049cefee1dc46b5a405805" id="r_a09a7d08859049cefee1dc46b5a405805"><td class="memItemLeft" align="right" valign="top"><a id="a09a7d08859049cefee1dc46b5a405805" name="a09a7d08859049cefee1dc46b5a405805"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>CombineMessageAndShiftRegister</b> (<a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *output, <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *reg, const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *message, size_t length)=0</td></tr>
<tr class="separator:a09a7d08859049cefee1dc46b5a405805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb03ad65083bbba86bdffcaf5d79da6" id="r_aecb03ad65083bbba86bdffcaf5d79da6"><td class="memItemLeft" align="right" valign="top"><a id="aecb03ad65083bbba86bdffcaf5d79da6" name="aecb03ad65083bbba86bdffcaf5d79da6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>UncheckedSetKey</b> (const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *key, unsigned int length, const <a class="el" href="class_name_value_pairs.html">NameValuePairs</a> &amp;params)</td></tr>
<tr class="separator:aecb03ad65083bbba86bdffcaf5d79da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a1360b5b5f16118705792176b1847027a" id="r_a1360b5b5f16118705792176b1847027a"><td class="memItemLeft" align="right" valign="top"><a id="a1360b5b5f16118705792176b1847027a" name="a1360b5b5f16118705792176b1847027a"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>m_leftOver</b></td></tr>
<tr class="separator:a1360b5b5f16118705792176b1847027a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class BASE&gt;<br />
class CFB_CipherTemplate&lt; BASE &gt;</div><p>Base class for feedback based stream ciphers with <a class="el" href="class_symmetric_cipher.html" title="Interface for one direction (encryption or decryption) of a stream cipher or cipher mode.">SymmetricCipher</a> interface. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BASE</td><td><a class="el" href="class_abstract_policy_holder.html" title="Access a stream cipher policy object.">AbstractPolicyHolder</a> base class </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a1f4c5691e5061fe3e0c2e161689b969e" name="a1f4c5691e5061fe3e0c2e161689b969e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f4c5691e5061fe3e0c2e161689b969e">&#9670;&#160;</a></span>AlgorithmProvider() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BASE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="class_c_f_b___cipher_template.html">CFB_CipherTemplate</a>&lt; BASE &gt;::AlgorithmProvider </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the provider of this algorithm. </p>
<dl class="section return"><dt>Returns</dt><dd>the algorithm provider</dd></dl>
<p>The algorithm provider can be a name like "C++", "SSE", "NEON", "AESNI", "ARMv8" and "Power8". C++ is standard C++ code. Other labels, like SSE, usually indicate a specialized implementation using instructions from a higher instruction set architecture (ISA). Future labels may include external hardware like a hardware security module (HSM).</p>
<p>Generally speaking Wei Dai's original IA-32 ASM code falls under "SSE2". Labels like "SSSE3" and "SSE4.1" follow after Wei's code and use intrinsics instead of ASM.</p>
<p>Algorithms which combine different instructions or ISAs provide the dominant one. For example on x86 <code>AES/GCM</code> returns "AESNI" rather than "CLMUL" or "AES+SSE4.1" or "AES+CLMUL" or "AES+SSE4.1+CLMUL". </p><dl class="section note"><dt>Note</dt><dd>Provider is not universally implemented yet. </dd></dl>

</div>
</div>
<a id="a1f4c5691e5061fe3e0c2e161689b969e" name="a1f4c5691e5061fe3e0c2e161689b969e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f4c5691e5061fe3e0c2e161689b969e">&#9670;&#160;</a></span>AlgorithmProvider() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BASE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="class_c_f_b___cipher_template.html">CFB_CipherTemplate</a>&lt; BASE &gt;::AlgorithmProvider </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the provider of this algorithm. </p>
<dl class="section return"><dt>Returns</dt><dd>the algorithm provider</dd></dl>
<p>The algorithm provider can be a name like "C++", "SSE", "NEON", "AESNI", "ARMv8" and "Power8". C++ is standard C++ code. Other labels, like SSE, usually indicate a specialized implementation using instructions from a higher instruction set architecture (ISA). Future labels may include external hardware like a hardware security module (HSM).</p>
<p>Generally speaking Wei Dai's original IA-32 ASM code falls under "SSE2". Labels like "SSSE3" and "SSE4.1" follow after Wei's code and use intrinsics instead of ASM.</p>
<p>Algorithms which combine different instructions or ISAs provide the dominant one. For example on x86 <code>AES/GCM</code> returns "AESNI" rather than "CLMUL" or "AES+SSE4.1" or "AES+CLMUL" or "AES+SSE4.1+CLMUL". </p><dl class="section note"><dt>Note</dt><dd>Provider is not universally implemented yet. </dd></dl>

</div>
</div>
<a id="adae738b3fbef96cb5ed6c0f37f6e9621" name="adae738b3fbef96cb5ed6c0f37f6e9621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adae738b3fbef96cb5ed6c0f37f6e9621">&#9670;&#160;</a></span>GetOptimalNextBlockSize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BASE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="class_c_f_b___cipher_template.html">CFB_CipherTemplate</a>&lt; BASE &gt;::GetOptimalNextBlockSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides number of ideal bytes to process. </p>
<dl class="section return"><dt>Returns</dt><dd>the ideal number of bytes to process</dd></dl>
<p>Internally, the default implementation returns remaining unprocessed bytes </p><dl class="section see"><dt>See also</dt><dd>GetBytesPerIteration() and <a class="el" href="#a3055f5f53d6770aacfb4c042f75e5dab" title="Provides number of ideal bytes to process.">OptimalBlockSize()</a> </dd></dl>

</div>
</div>
<a id="adae738b3fbef96cb5ed6c0f37f6e9621" name="adae738b3fbef96cb5ed6c0f37f6e9621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adae738b3fbef96cb5ed6c0f37f6e9621">&#9670;&#160;</a></span>GetOptimalNextBlockSize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BASE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="class_c_f_b___cipher_template.html">CFB_CipherTemplate</a>&lt; BASE &gt;::GetOptimalNextBlockSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides number of ideal bytes to process. </p>
<dl class="section return"><dt>Returns</dt><dd>the ideal number of bytes to process</dd></dl>
<p>Internally, the default implementation returns remaining unprocessed bytes </p><dl class="section see"><dt>See also</dt><dd>GetBytesPerIteration() and <a class="el" href="#a3055f5f53d6770aacfb4c042f75e5dab" title="Provides number of ideal bytes to process.">OptimalBlockSize()</a> </dd></dl>

</div>
</div>
<a id="a71489329f90306fbf7916335b9bc0ca9" name="a71489329f90306fbf7916335b9bc0ca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71489329f90306fbf7916335b9bc0ca9">&#9670;&#160;</a></span>IsRandomAccess() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BASE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_c_f_b___cipher_template.html">CFB_CipherTemplate</a>&lt; BASE &gt;::IsRandomAccess </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flag indicating random access. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the cipher is seekable, false otherwise </dd></dl>
<dl class="section see"><dt>See also</dt><dd>Seek() </dd></dl>

</div>
</div>
<a id="a71489329f90306fbf7916335b9bc0ca9" name="a71489329f90306fbf7916335b9bc0ca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71489329f90306fbf7916335b9bc0ca9">&#9670;&#160;</a></span>IsRandomAccess() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BASE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_c_f_b___cipher_template.html">CFB_CipherTemplate</a>&lt; BASE &gt;::IsRandomAccess </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flag indicating random access. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the cipher is seekable, false otherwise </dd></dl>
<dl class="section see"><dt>See also</dt><dd>Seek() </dd></dl>

</div>
</div>
<a id="add3c4fa05f62c3e601faa4a469ee108d" name="add3c4fa05f62c3e601faa4a469ee108d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add3c4fa05f62c3e601faa4a469ee108d">&#9670;&#160;</a></span>IsSelfInverting() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BASE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_c_f_b___cipher_template.html">CFB_CipherTemplate</a>&lt; BASE &gt;::IsSelfInverting </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the cipher is self inverting. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the stream cipher is self inverting, false otherwise </dd></dl>

</div>
</div>
<a id="add3c4fa05f62c3e601faa4a469ee108d" name="add3c4fa05f62c3e601faa4a469ee108d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add3c4fa05f62c3e601faa4a469ee108d">&#9670;&#160;</a></span>IsSelfInverting() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BASE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_c_f_b___cipher_template.html">CFB_CipherTemplate</a>&lt; BASE &gt;::IsSelfInverting </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the cipher is self inverting. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the stream cipher is self inverting, false otherwise </dd></dl>

</div>
</div>
<a id="a3055f5f53d6770aacfb4c042f75e5dab" name="a3055f5f53d6770aacfb4c042f75e5dab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3055f5f53d6770aacfb4c042f75e5dab">&#9670;&#160;</a></span>OptimalBlockSize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BASE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="class_c_f_b___cipher_template.html">CFB_CipherTemplate</a>&lt; BASE &gt;::OptimalBlockSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides number of ideal bytes to process. </p>
<dl class="section return"><dt>Returns</dt><dd>the ideal number of bytes to process</dd></dl>
<p>Internally, the default implementation returns GetBytesPerIteration() </p><dl class="section see"><dt>See also</dt><dd>GetBytesPerIteration() and <a class="el" href="#adae738b3fbef96cb5ed6c0f37f6e9621" title="Provides number of ideal bytes to process.">GetOptimalNextBlockSize()</a> </dd></dl>

</div>
</div>
<a id="a3055f5f53d6770aacfb4c042f75e5dab" name="a3055f5f53d6770aacfb4c042f75e5dab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3055f5f53d6770aacfb4c042f75e5dab">&#9670;&#160;</a></span>OptimalBlockSize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BASE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="class_c_f_b___cipher_template.html">CFB_CipherTemplate</a>&lt; BASE &gt;::OptimalBlockSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides number of ideal bytes to process. </p>
<dl class="section return"><dt>Returns</dt><dd>the ideal number of bytes to process</dd></dl>
<p>Internally, the default implementation returns GetBytesPerIteration() </p><dl class="section see"><dt>See also</dt><dd>GetBytesPerIteration() and <a class="el" href="#adae738b3fbef96cb5ed6c0f37f6e9621" title="Provides number of ideal bytes to process.">GetOptimalNextBlockSize()</a> </dd></dl>

</div>
</div>
<a id="a3efd5acd93a2e3601d80bbbf9beaaf1d" name="a3efd5acd93a2e3601d80bbbf9beaaf1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3efd5acd93a2e3601d80bbbf9beaaf1d">&#9670;&#160;</a></span>OptimalDataAlignment() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BASE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="class_c_f_b___cipher_template.html">CFB_CipherTemplate</a>&lt; BASE &gt;::OptimalDataAlignment </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides number of ideal data alignment. </p>
<dl class="section return"><dt>Returns</dt><dd>the ideal data alignment, in bytes </dd></dl>
<dl class="section see"><dt>See also</dt><dd>GetAlignment() and <a class="el" href="#a3055f5f53d6770aacfb4c042f75e5dab" title="Provides number of ideal bytes to process.">OptimalBlockSize()</a> </dd></dl>

</div>
</div>
<a id="a3efd5acd93a2e3601d80bbbf9beaaf1d" name="a3efd5acd93a2e3601d80bbbf9beaaf1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3efd5acd93a2e3601d80bbbf9beaaf1d">&#9670;&#160;</a></span>OptimalDataAlignment() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BASE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="class_c_f_b___cipher_template.html">CFB_CipherTemplate</a>&lt; BASE &gt;::OptimalDataAlignment </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides number of ideal data alignment. </p>
<dl class="section return"><dt>Returns</dt><dd>the ideal data alignment, in bytes </dd></dl>
<dl class="section see"><dt>See also</dt><dd>GetAlignment() and <a class="el" href="#a3055f5f53d6770aacfb4c042f75e5dab" title="Provides number of ideal bytes to process.">OptimalBlockSize()</a> </dd></dl>

</div>
</div>
<a id="adf14a759fd95fd687f4e257264771f89" name="adf14a759fd95fd687f4e257264771f89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf14a759fd95fd687f4e257264771f89">&#9670;&#160;</a></span>ProcessData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BASE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_c_f_b___cipher_template.html">CFB_CipherTemplate</a>&lt; BASE &gt;::ProcessData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *</td>          <td class="paramname"><span class="paramname"><em>outString</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *</td>          <td class="paramname"><span class="paramname"><em>inString</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply keystream to data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outString</td><td>a buffer to write the transformed data </td></tr>
    <tr><td class="paramname">inString</td><td>a buffer to read the data </td></tr>
    <tr><td class="paramname">length</td><td>the size of the buffers, in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>This is the primary method to operate a stream cipher. For example: </p><pre>
    size_t size = 30;
    byte plain[size] = "Do or do not; there is no try";
    byte cipher[size];
    ...
    ChaCha20 chacha(key, keySize);
    chacha.ProcessData(cipher, plain, size);
</pre><p>You should use distinct buffers for inString and outString. If the buffers are the same, then the data will be copied to an internal buffer to avoid GCC alias violations. The internal copy will impact performance. </p><dl class="section see"><dt>See also</dt><dd><a href="https://github.com/weidai11/cryptopp/issues/1088">Issue 1088, 36% loss of performance with AES</a>, <a href="https://github.com/weidai11/cryptopp/issues/1010">Issue 1010, HIGHT cipher troubles with FileSource</a> </dd></dl>

</div>
</div>
<a id="adf14a759fd95fd687f4e257264771f89" name="adf14a759fd95fd687f4e257264771f89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf14a759fd95fd687f4e257264771f89">&#9670;&#160;</a></span>ProcessData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BASE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_c_f_b___cipher_template.html">CFB_CipherTemplate</a>&lt; BASE &gt;::ProcessData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *</td>          <td class="paramname"><span class="paramname"><em>outString</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *</td>          <td class="paramname"><span class="paramname"><em>inString</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply keystream to data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outString</td><td>a buffer to write the transformed data </td></tr>
    <tr><td class="paramname">inString</td><td>a buffer to read the data </td></tr>
    <tr><td class="paramname">length</td><td>the size of the buffers, in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>This is the primary method to operate a stream cipher. For example: </p><pre>
    size_t size = 30;
    byte plain[size] = "Do or do not; there is no try";
    byte cipher[size];
    ...
    ChaCha20 chacha(key, keySize);
    chacha.ProcessData(cipher, plain, size);
</pre><p>You should use distinct buffers for inString and outString. If the buffers are the same, then the data will be copied to an internal buffer to avoid GCC alias violations. The internal copy will impact performance. </p><dl class="section see"><dt>See also</dt><dd><a href="https://github.com/weidai11/cryptopp/issues/1088">Issue 1088, 36% loss of performance with AES</a>, <a href="https://github.com/weidai11/cryptopp/issues/1010">Issue 1010, HIGHT cipher troubles with FileSource</a> </dd></dl>

</div>
</div>
<a id="a8604f13ab0f11d510c8e1f28526333a0" name="a8604f13ab0f11d510c8e1f28526333a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8604f13ab0f11d510c8e1f28526333a0">&#9670;&#160;</a></span>Resynchronize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BASE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_c_f_b___cipher_template.html">CFB_CipherTemplate</a>&lt; BASE &gt;::Resynchronize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *</td>          <td class="paramname"><span class="paramname"><em>iv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resynchronize the cipher. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iv</td><td>a byte array used to resynchronize the cipher </td></tr>
    <tr><td class="paramname">length</td><td>the size of the IV array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8604f13ab0f11d510c8e1f28526333a0" name="a8604f13ab0f11d510c8e1f28526333a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8604f13ab0f11d510c8e1f28526333a0">&#9670;&#160;</a></span>Resynchronize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BASE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_c_f_b___cipher_template.html">CFB_CipherTemplate</a>&lt; BASE &gt;::Resynchronize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *</td>          <td class="paramname"><span class="paramname"><em>iv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resynchronize the cipher. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iv</td><td>a byte array used to resynchronize the cipher </td></tr>
    <tr><td class="paramname">length</td><td>the size of the IV array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/Admin/Downloads/NT219/cryptopp/include/cryptopp/<a class="el" href="include_2cryptopp_2strciphr_8h_source.html">strciphr.h</a></li>
<li>C:/Users/Admin/Downloads/NT219/cryptopp/<a class="el" href="strciphr_8h_source.html">strciphr.h</a></li>
<li>C:/Users/Admin/Downloads/NT219/cryptopp/<b>strciphr.cpp</b></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_c_f_b___cipher_template.html">CFB_CipherTemplate</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
